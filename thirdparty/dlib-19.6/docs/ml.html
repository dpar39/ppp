<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html xmlns:gcse="googleCustomSearch"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="shortcut icon" href="dlib-icon.ico"><meta name="verify-v1" content="02MiiaFNVzS5/u0eQhsy3/knioFHsia1X3DXRpHkE6I="><meta name="google-site-verification" content="DGSSJMKDomaDaDTIRJ8jDkv0YMx9Cz7OESbXHjjr6Jw"><title>dlib C++ Library
               - Machine Learning</title><script type="text/javascript" src="dlib.js"></script><link rel="stylesheet" type="text/css" href="dlib.css"></head><body><a name="top"></a><div id="page_header"><a href="http://dlib.net"><img src="dlib-logo.png"></a></div><div id="top_content"><div id="main_menu" class="menu"><div class="menu_top"><b>The Library</b><ul class="tree"><li><a href="algorithms.html" class="menu">Algorithms</a></li><li><a href="api.html" class="menu">API Wrappers</a></li><li><a href="bayes.html" class="menu">Bayesian Nets</a></li><li><a href="compression.html" class="menu">Compression</a></li><li><a href="containers.html" class="menu">Containers</a></li><li><a href="graph_tools.html" class="menu">Graph Tools</a></li><li><a href="imaging.html" class="menu">Image Processing</a></li><li><a href="linear_algebra.html" class="menu">Linear Algebra</a></li><li><a href="ml.html" class="menu">Machine Learning</a></li><li><a href="metaprogramming.html" class="menu">Metaprogramming</a></li><li><a href="other.html" class="menu">Miscellaneous</a></li><li><a href="network.html" class="menu">Networking</a></li><li><a href="optimization.html" class="menu">Optimization</a></li><li><a href="parsing.html" class="menu">Parsing</a></li></ul><br><b>Help/Info</b><ul class="tree"><li><a href="http://blog.dlib.net" class="menu">Dlib Blog</a></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Examples: C++</a><ul style="display:none;"><li><a href="3d_point_cloud_ex.cpp.html" class="menu">3D Point Cloud</a></li><li><a href="assignment_learning_ex.cpp.html" class="menu">Assignment Learning</a></li><li><a href="file_to_code_ex.cpp.html" class="menu">Base64 Encoder</a></li><li><a href="bayes_net_from_disk_ex.cpp.html" class="menu">Bayesian Network From Disk</a></li><li><a href="bayes_net_gui_ex.cpp.html" class="menu">Bayesian Network GUI</a></li><li><a href="bayes_net_ex.cpp.html" class="menu">Bayesian Network</a></li><li><a href="bridge_ex.cpp.html" class="menu">Bridge</a></li><li><a href="bsp_ex.cpp.html" class="menu">BSP</a></li><li><a href="svm_c_ex.cpp.html" class="menu">C-Support Vector Machine</a></li><li><a href="compress_stream_ex.cpp.html#_top" class="menu">Cmd Line Parser</a></li><li><a href="compress_stream_ex.cpp.html" class="menu">Compress Stream</a></li><li><a href="config_reader_ex.cpp.html" class="menu">Config File Reader</a></li><li><a href="custom_trainer_ex.cpp.html" class="menu">Custom Trainers</a></li><li><a href="dnn_face_recognition_ex.cpp.html" class="menu">Deep Face Recognition</a></li><li><a href="dnn_mmod_dog_hipsterizer.cpp.html" class="menu">Deep Learning Dog Hipsterizer</a></li><li><a href="dnn_mmod_face_detection_ex.cpp.html" class="menu">Deep Learning Face Detection</a></li><li><a href="dnn_imagenet_ex.cpp.html" class="menu">Deep Learning Imagenet Classifier</a></li><li><a href="dnn_imagenet_train_ex.cpp.html" class="menu">Deep Learning Imagenet Trainer </a></li><li><a href="dnn_inception_ex.cpp.html" class="menu">Deep Learning Inception</a></li><li><a href="dnn_introduction_ex.cpp.html" class="menu">Deep Learning Introduction Part 1</a></li><li><a href="dnn_introduction2_ex.cpp.html" class="menu">Deep Learning Introduction Part 2</a></li><li><a href="dnn_mmod_ex.cpp.html" class="menu">Deep Learning Max-Margin Object Detection</a></li><li><a href="dnn_mmod_train_find_cars_ex.cpp.html" class="menu">Deep Learning Vehicle Detection Trainer</a></li><li><a href="dnn_mmod_find_cars_ex.cpp.html" class="menu">Deep Learning Vehicle Detection</a></li><li><a href="dnn_metric_learning_ex.cpp.html" class="menu">Deep Metric Learning Introduction</a></li><li><a href="dnn_metric_learning_on_images_ex.cpp.html" class="menu">Deep Metric Learning on Images</a></li><li><a href="dir_nav_ex.cpp.html" class="menu">Directory Navigation</a></li><li><a href="empirical_kernel_map_ex.cpp.html" class="menu">Empirical Kernel Map</a></li><li><a href="face_detection_ex.cpp.html" class="menu">Face Detection</a></li><li><a href="face_landmark_detection_ex.cpp.html" class="menu">Face Landmark Detection</a></li><li><a href="fhog_ex.cpp.html" class="menu">FHOG Feature Extraction</a></li><li><a href="fhog_object_detector_ex.cpp.html" class="menu">FHOG Object Detection</a></li><li><a href="graph_labeling_ex.cpp.html" class="menu">Graph Labeling</a></li><li><a href="gui_api_ex.cpp.html" class="menu">GUI</a></li><li><a href="hough_transform_ex.cpp.html" class="menu">Hough Transform</a></li><li><a href="server_http_ex.cpp.html" class="menu">HTTP Server</a></li><li><a href="image_ex.cpp.html" class="menu">Image</a></li><li><a href="iosockstream_ex.cpp.html" class="menu">IO Socket Streams</a></li><li><a href="server_iostream_ex.cpp.html" class="menu">IO Streams Server</a></li><li><a href="kcentroid_ex.cpp.html" class="menu">Kernel Centroid</a></li><li><a href="kkmeans_ex.cpp.html" class="menu">Kernel K-Means Clustering</a></li><li><a href="krr_regression_ex.cpp.html" class="menu">Kernel Ridge Regression</a></li><li><a href="krls_filter_ex.cpp.html" class="menu">Kernel RLS Filtering</a></li><li><a href="krls_ex.cpp.html" class="menu">Kernel RLS Regression</a></li><li><a href="krr_classification_ex.cpp.html" class="menu">KRR Classification</a></li><li><a href="learning_to_track_ex.cpp.html" class="menu">Learning to Track</a></li><li><a href="max_cost_assignment_ex.cpp.html" class="menu">Linear Assignment Problems</a></li><li><a href="linear_manifold_regularizer_ex.cpp.html" class="menu">Linear Manifold Regularizer</a></li><li><a href="mpc_ex.cpp.html" class="menu">Linear Model Predictive Control</a></li><li><a href="logger_ex_2.cpp.html" class="menu">Logger Advanced</a></li><li><a href="logger_custom_output_ex.cpp.html" class="menu">Logger Custom Output</a></li><li><a href="logger_ex.cpp.html" class="menu">Logger</a></li><li><a href="matrix_expressions_ex.cpp.html" class="menu">Matrix Expressions</a></li><li><a href="matrix_ex.cpp.html" class="menu">Matrix</a></li><li><a href="member_function_pointer_ex.cpp.html" class="menu">Member Function Pointer</a></li><li><a href="model_selection_ex.cpp.html" class="menu">Model Selection</a></li><li><a href="multiclass_classification_ex.cpp.html" class="menu">Multiclass Classification</a></li><li><a href="multithreaded_object_ex.cpp.html" class="menu">Multithreaded Object</a></li><li><a href="mlp_ex.cpp.html" class="menu">Neural Network</a></li><li><a href="least_squares_ex.cpp.html" class="menu">Non-Linear Least Squares</a></li><li><a href="svm_ex.cpp.html" class="menu">Nu-Support Vector Machine</a></li><li><a href="integrate_function_adapt_simp_ex.cpp.html" class="menu">Numerical Integration</a></li><li><a href="object_detector_advanced_ex.cpp.html" class="menu">Object Detector Advanced</a></li><li><a href="object_detector_ex.cpp.html" class="menu">Object Detector</a></li><li><a href="one_class_classifiers_ex.cpp.html" class="menu">One Class Classifiers</a></li><li><a href="svm_pegasos_ex.cpp.html" class="menu">Online SVM</a></li><li><a href="optimization_ex.cpp.html" class="menu">Optimization</a></li><li><a href="parallel_for_ex.cpp.html" class="menu">Parallel For Loops</a></li><li><a href="pipe_ex_2.cpp.html" class="menu">Pipe 2</a></li><li><a href="pipe_ex.cpp.html" class="menu">Pipe</a></li><li><a href="quantum_computing_ex.cpp.html" class="menu">Quantum Computing</a></li><li><a href="queue_ex.cpp.html" class="menu">Queue</a></li><li><a href="random_cropper_ex.cpp.html" class="menu">Random Cropper</a></li><li><a href="rank_features_ex.cpp.html" class="menu">Rank Features</a></li><li><a href="rvm_ex.cpp.html" class="menu">Relevance Vector Classification</a></li><li><a href="rvm_regression_ex.cpp.html" class="menu">Relevance Vector Regression</a></li><li><a href="running_stats_ex.cpp.html" class="menu">Running Stats</a></li><li><a href="sequence_labeler_ex.cpp.html" class="menu">Sequence Labeling</a></li><li><a href="sequence_segmenter_ex.cpp.html" class="menu">Sequence Segmentation</a></li><li><a href="sockets_ex.cpp.html" class="menu">Sockets</a></li><li><a href="sockstreambuf_ex.cpp.html" class="menu">Sockstreambuf</a></li><li><a href="svm_sparse_ex.cpp.html" class="menu">Sparse Vectors</a></li><li><a href="sqlite_ex.cpp.html" class="menu">SQLite</a></li><li><a href="std_allocator_ex.cpp.html" class="menu">Std C++ Allocator</a></li><li><a href="svm_struct_ex.cpp.html" class="menu">Structural Support Vector Machines</a></li><li><a href="svr_ex.cpp.html" class="menu">Support Vector Regression</a></li><li><a href="surf_ex.cpp.html" class="menu">SURF</a></li><li><a href="svm_rank_ex.cpp.html" class="menu">SVM-Rank</a></li><li><a href="thread_function_ex.cpp.html" class="menu">Thread Function</a></li><li><a href="thread_pool_ex.cpp.html" class="menu">Thread Pool</a></li><li><a href="threaded_object_ex.cpp.html" class="menu">Threaded Object</a></li><li><a href="threads_ex.cpp.html" class="menu">Threads</a></li><li><a href="timer_ex.cpp.html" class="menu">Timer</a></li><li><a href="train_object_detector.cpp.html" class="menu">Train Object Detector</a></li><li><a href="train_shape_predictor_ex.cpp.html" class="menu">Train Shape Predictor</a></li><li><a href="using_custom_kernels_ex.cpp.html" class="menu">Using Custom Kernels</a></li><li><a href="video_tracking_ex.cpp.html" class="menu">Video Object Tracking</a></li><li><a href="webcam_face_pose_ex.cpp.html" class="menu">Webcam Face Pose Estimation</a></li><li><a href="xml_parser_ex.cpp.html" class="menu">XML Parser</a></li></ul></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Examples: Python</a><ul style="display:none;"><li><a href="cnn_face_detector.py.html" class="menu">CNN Face Detector</a></li><li><a href="face_detector.py.html" class="menu">Face Detector</a></li><li><a href="face_landmark_detection.py.html" class="menu">Face Landmark Detection</a></li><li><a href="face_recognition.py.html" class="menu">Face Recognition</a></li><li><a href="find_candidate_object_locations.py.html" class="menu">Find Candidate Object Locations</a></li><li><a href="max_cost_assignment.py.html" class="menu">Linear Assignment Problems</a></li><li><a href="sequence_segmenter.py.html" class="menu">Sequence Segmenter</a></li><li><a href="svm_struct.py.html" class="menu">Structural Support Vector Machines</a></li><li><a href="svm_rank.py.html" class="menu">SVM-Rank</a></li><li><a href="train_object_detector.py.html" class="menu">Train Object Detector</a></li><li><a href="train_shape_predictor.py.html" class="menu">Train Shape Predictor</a></li><li><a href="correlation_tracker.py.html" class="menu">Video Object Tracking</a></li></ul></li><li><a href="faq.html" class="menu">FAQ</a></li><li><a href="index.html" class="menu">Home</a></li><li><a href="compile.html" class="menu">How to compile</a></li><li><a href="howto_contribute.html" class="menu">How to contribute</a></li><li><a href="term_index.html" class="menu">Index</a></li><li><a href="intro.html" class="menu">Introduction</a></li><li><a href="license.html" class="menu">License</a></li><li><a href="python/index.html" class="menu">Python API</a></li><li><a href="books.html" class="menu">Suggested Books</a></li><li><a href="http://sourceforge.net/p/dclib/wiki/Known_users/" class="menu">Who uses dlib?</a></li></ul><br><b>Current Release</b><ul class="tree"><li><a href="change_log.html" class="menu">Change Log</a></li><li><a href="release_notes.html" class="menu">Release Notes</a></li><li>Version: 19.6</li></ul><br></div><div class="menu_footer">
      Last Modified:<br>Aug 27, 2017</div></div><div id="main_text"><div id="main_text_title">Machine Learning</div><div id="main_text_body"><a href="ml_guide.svg"><img src="ml_guide.svg" border="0" height="" width="100%" alt=""></a><br><br><p><font color="" style="font-size:1.4em;line-height:1.1em">   
            Dlib contains a wide range of machine learning algorithms.  All
            designed to be highly modular, quick to execute, and simple to use
            via a clean and modern C++ API.   It is used in a wide range of
            applications including robotics, embedded devices, mobile phones, and large
            high performance computing environments.  If you use dlib in your
            research please cite:
         </font></p><pre>
Davis E. King. <a href="http://jmlr.csail.mit.edu/papers/volume10/king09a/king09a.pdf">Dlib-ml: A Machine Learning Toolkit</a>. 
   <i>Journal of Machine Learning Research</i>, 2009

@Article{dlib09,
  author = {Davis E. King},
  title = {Dlib-ml: A Machine Learning Toolkit},
  journal = {Journal of Machine Learning Research},
  year = {2009},
  volume = {10},
  pages = {1755-1758},
}
         </pre></div></div><div id="right_menu" class="menu"><div class="menu_top"><center><a name="Primary%20Algorithms"></a><h2><u>Primary Algorithms</u></h2></center><b>Binary Classification</b><ul class="tree"><li><a href="#rvm_trainer" class="menu">rvm_trainer</a></li><li><a href="#svm_c_ekm_trainer" class="menu">svm_c_ekm_trainer</a></li><li><a href="#svm_c_linear_dcd_trainer" class="menu">svm_c_linear_dcd_trainer</a></li><li><a href="#svm_c_linear_trainer" class="menu">svm_c_linear_trainer</a></li><li><a href="#svm_c_trainer" class="menu">svm_c_trainer</a></li><li><a href="#svm_nu_trainer" class="menu">svm_nu_trainer</a></li><li><a href="#svm_pegasos" class="menu">svm_pegasos</a></li><li><a href="#train_probabilistic_decision_function" class="menu">train_probabilistic_decision_function</a></li></ul><br><b>Multiclass Classification</b><ul class="tree"><li><a href="#one_vs_all_trainer" class="menu">one_vs_all_trainer</a></li><li><a href="#one_vs_one_trainer" class="menu">one_vs_one_trainer</a></li><li><a href="#svm_multiclass_linear_trainer" class="menu">svm_multiclass_linear_trainer</a></li></ul><br><b>Regression</b><ul class="tree"><li><a href="#krls" class="menu">krls</a></li><li><a href="#krr_trainer" class="menu">krr_trainer</a></li><li><a href="#mlp" class="menu">mlp</a></li><li><a href="#rbf_network_trainer" class="menu">rbf_network_trainer</a></li><li><a href="#rls" class="menu">rls</a></li><li><a href="#rr_trainer" class="menu">rr_trainer</a></li><li><a href="#rvm_regression_trainer" class="menu">rvm_regression_trainer</a></li><li><a href="#svr_linear_trainer" class="menu">svr_linear_trainer</a></li><li><a href="#svr_trainer" class="menu">svr_trainer</a></li></ul><br><b>Structured Prediction</b><ul class="tree"><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Core Tools</a><ul style="display:none;"><li><a href="#structural_svm_problem" class="menu">structural_svm_problem</a></li><li><a href="#structural_svm_problem_threaded" class="menu">structural_svm_problem_threaded</a></li><li><a href="#svm_struct_controller_node" class="menu">svm_struct_controller_node</a></li><li><a href="#svm_struct_processing_node" class="menu">svm_struct_processing_node</a></li></ul></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Problem Instances</a><ul style="display:none;"><li><a href="#structural_svm_assignment_problem" class="menu">structural_svm_assignment_problem</a></li><li><a href="#structural_svm_graph_labeling_problem" class="menu">structural_svm_graph_labeling_problem</a></li><li><a href="#structural_svm_object_detection_problem" class="menu">structural_svm_object_detection_problem</a></li><li><a href="#structural_svm_sequence_labeling_problem" class="menu">structural_svm_sequence_labeling_problem</a></li></ul></li><li><a href="#shape_predictor_trainer" class="menu">shape_predictor_trainer</a></li><li><a href="#structural_assignment_trainer" class="menu">structural_assignment_trainer</a></li><li><a href="#structural_graph_labeling_trainer" class="menu">structural_graph_labeling_trainer</a></li><li><a href="#structural_object_detection_trainer" class="menu">structural_object_detection_trainer</a></li><li><a href="#structural_sequence_labeling_trainer" class="menu">structural_sequence_labeling_trainer</a></li><li><a href="#structural_sequence_segmentation_trainer" class="menu">structural_sequence_segmentation_trainer</a></li><li><a href="#structural_track_association_trainer" class="menu">structural_track_association_trainer</a></li><li><a href="#svm_rank_trainer" class="menu">svm_rank_trainer</a></li></ul><br><b>Deep Learning</b><ul class="tree"><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Computational Layers</a><ul style="display:none;"><li><a href="dlib/dnn/layers_abstract.h.html#add_prev_" class="menu">add_prev</a></li><li><a href="dlib/dnn/layers_abstract.h.html#affine_" class="menu">affine</a></li><li><a href="dlib/dnn/layers_abstract.h.html#avg_pool_" class="menu">avg_pool</a></li><li><a href="dlib/dnn/layers_abstract.h.html#bn_" class="menu">bn</a></li><li><a href="dlib/dnn/layers_abstract.h.html#concat_" class="menu">concat</a></li><li><a href="dlib/dnn/layers_abstract.h.html#con_" class="menu">con</a></li><li><a href="dlib/dnn/layers_abstract.h.html#cont_" class="menu">cont</a></li><li><a href="dlib/dnn/layers_abstract.h.html#dropout_" class="menu">dropout</a></li><li><a href="dlib/dnn/layers_abstract.h.html#EXAMPLE_COMPUTATIONAL_LAYER_" class="menu">EXAMPLE_COMPUTATIONAL_LAYER</a></li><li><a href="dlib/dnn/layers_abstract.h.html#extract_" class="menu">extract</a></li><li><a href="dlib/dnn/layers_abstract.h.html#fc_" class="menu">fc</a></li><li><a href="dlib/dnn/layers_abstract.h.html#htan_" class="menu">htan</a></li><li><a href="dlib/dnn/layers_abstract.h.html#inception" class="menu">inception</a></li><li><a href="dlib/dnn/layers_abstract.h.html#l2normalize_" class="menu">l2normalize</a></li><li><a href="dlib/dnn/layers_abstract.h.html#max_pool_" class="menu">max_pool</a></li><li><a href="dlib/dnn/layers_abstract.h.html#multiply_" class="menu">multiply</a></li><li><a href="dlib/dnn/layers_abstract.h.html#mult_prev_" class="menu">mult_prev</a></li><li><a href="dlib/dnn/layers_abstract.h.html#prelu_" class="menu">prelu</a></li><li><a href="dlib/dnn/layers_abstract.h.html#relu_" class="menu">relu</a></li><li><a href="dlib/dnn/layers_abstract.h.html#sig_" class="menu">sig</a></li><li><a href="dlib/dnn/layers_abstract.h.html#softmax_" class="menu">softmax</a></li><li><a href="dlib/dnn/layers_abstract.h.html#upsample_" class="menu">upsample</a></li></ul></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Core Tools</a><ul style="display:none;"><li><a href="#add_layer" class="menu">add_layer</a></li><li><a href="#add_loss_layer" class="menu">add_loss_layer</a></li><li><a href="#add_skip_layer" class="menu">add_skip_layer</a></li><li><a href="#add_tag_layer" class="menu">add_tag_layer</a></li><li><a href="#alias_tensor" class="menu">alias_tensor</a></li><li><a href="#dnn_trainer" class="menu">dnn_trainer</a></li><li><a href="#layer" class="menu">layer</a></li><li><a href="#repeat" class="menu">repeat</a></li><li><a href="#resizable_tensor" class="menu">resizable_tensor</a></li><li><a href="#test_layer" class="menu">test_layer</a></li></ul></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Input Layers</a><ul style="display:none;"><li><a href="dlib/dnn/input_abstract.h.html#EXAMPLE_INPUT_LAYER" class="menu">EXAMPLE_INPUT_LAYER</a></li><li><a href="#input" class="menu">input</a></li><li><a href="#input_rgb_image" class="menu">input_rgb_image</a></li><li><a href="#input_rgb_image_pyramid" class="menu">input_rgb_image_pyramid</a></li><li><a href="#input_rgb_image_sized" class="menu">input_rgb_image_sized</a></li></ul></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Loss Layers</a><ul style="display:none;"><li><a href="dlib/dnn/loss_abstract.h.html#EXAMPLE_LOSS_LAYER_" class="menu">EXAMPLE_LOSS_LAYER</a></li><li><a href="dlib/dnn/loss_abstract.h.html#loss_binary_hinge_" class="menu">loss_binary_hinge</a></li><li><a href="dlib/dnn/loss_abstract.h.html#loss_binary_log_" class="menu">loss_binary_log</a></li><li><a href="#loss_mean_squared_" class="menu">loss_mean_squared</a></li><li><a href="dlib/dnn/loss_abstract.h.html#loss_mean_squared_multioutput_" class="menu">loss_mean_squared_multioutput_</a></li><li><a href="#loss_mean_squared_per_pixel_" class="menu">loss_mean_squared_per_pixel</a></li><li><a href="#loss_metric_" class="menu">loss_metric</a></li><li><a href="#loss_mmod_" class="menu">loss_mmod</a></li><li><a href="dlib/dnn/loss_abstract.h.html#loss_multiclass_log_" class="menu">loss_multiclass_log</a></li><li><a href="dlib/dnn/loss_abstract.h.html#loss_multiclass_log_per_pixel_" class="menu">loss_multiclass_log_per_pixel</a></li><li><a href="dlib/dnn/loss_abstract.h.html#loss_multiclass_log_per_pixel_weighted_" class="menu">loss_multiclass_log_per_pixel_weighted</a></li></ul></li><li><a onclick="Toggle(this)" class="sub menu"><img src="plus.gif">Solvers</a><ul style="display:none;"><li><a href="dlib/dnn/solvers_abstract.h.html#adam" class="menu">adam</a></li><li><a href="dlib/dnn/solvers_abstract.h.html#EXAMPLE_SOLVER" class="menu">EXAMPLE_SOLVER</a></li><li><a href="dlib/dnn/solvers_abstract.h.html#sgd" class="menu">sgd</a></li></ul></li></ul><br><b>Clustering</b><ul class="tree"><li><a href="#bottom_up_cluster" class="menu">bottom_up_cluster</a></li><li><a href="#chinese_whispers" class="menu">chinese_whispers</a></li><li><a href="#find_clusters_using_angular_kmeans" class="menu">find_clusters_using_angular_kmeans</a></li><li><a href="#find_clusters_using_kmeans" class="menu">find_clusters_using_kmeans</a></li><li><a href="#kkmeans" class="menu">kkmeans</a></li><li><a href="#modularity" class="menu">modularity</a></li><li><a href="#nearest_center" class="menu">nearest_center</a></li><li><a href="#newman_cluster" class="menu">newman_cluster</a></li><li><a href="#pick_initial_centers" class="menu">pick_initial_centers</a></li><li><a href="#segment_number_line" class="menu">segment_number_line</a></li><li><a href="#spectral_cluster" class="menu">spectral_cluster</a></li></ul><br><b>Unsupervised</b><ul class="tree"><li><a href="#cca" class="menu">cca</a></li><li><a href="#empirical_kernel_map" class="menu">empirical_kernel_map</a></li><li><a href="#kcentroid" class="menu">kcentroid</a></li><li><a href="#linearly_independent_subset_finder" class="menu">linearly_independent_subset_finder</a></li><li><a href="#sammon_projection" class="menu">sammon_projection</a></li><li><a href="#svm_one_class_trainer" class="menu">svm_one_class_trainer</a></li><li><a href="#vector_normalizer" class="menu">vector_normalizer</a></li><li><a href="#vector_normalizer_pca" class="menu">vector_normalizer_pca</a></li></ul><br><b>Semi-Supervised/Metric Learning</b><ul class="tree"><li><a href="#compute_lda_transform" class="menu">compute_lda_transform</a></li><li><a href="#discriminant_pca" class="menu">discriminant_pca</a></li><li><a href="#linear_manifold_regularizer" class="menu">linear_manifold_regularizer</a></li><li><a href="#vector_normalizer_frobmetric" class="menu">vector_normalizer_frobmetric</a></li></ul><br><b>Reinforcement Learning</b><ul class="tree"><li><a href="#lspi" class="menu">lspi</a></li></ul><br><b>Feature Selection</b><ul class="tree"><li><a href="#rank_features" class="menu">rank_features</a></li><li><a href="#rank_unlabeled_training_samples" class="menu">rank_unlabeled_training_samples</a></li><li><a href="#sort_basis_vectors" class="menu">sort_basis_vectors</a></li></ul><br><center><a name="Other%20Tools"></a><h2><u>Other Tools</u></h2></center><b>Validation</b><ul class="tree"><li><a href="#average_precision" class="menu">average_precision</a></li><li><a href="#compute_roc_curve" class="menu">compute_roc_curve</a></li><li><a href="#cross_validate_assignment_trainer" class="menu">cross_validate_assignment_trainer</a></li><li><a href="#cross_validate_graph_labeling_trainer" class="menu">cross_validate_graph_labeling_trainer</a></li><li><a href="#cross_validate_multiclass_trainer" class="menu">cross_validate_multiclass_trainer</a></li><li><a href="#cross_validate_object_detection_trainer" class="menu">cross_validate_object_detection_trainer</a></li><li><a href="#cross_validate_ranking_trainer" class="menu">cross_validate_ranking_trainer</a></li><li><a href="#cross_validate_regression_trainer" class="menu">cross_validate_regression_trainer</a></li><li><a href="#cross_validate_sequence_labeler" class="menu">cross_validate_sequence_labeler</a></li><li><a href="#cross_validate_sequence_segmenter" class="menu">cross_validate_sequence_segmenter</a></li><li><a href="#cross_validate_track_association_trainer" class="menu">cross_validate_track_association_trainer</a></li><li><a href="#cross_validate_trainer" class="menu">cross_validate_trainer</a></li><li><a href="#cross_validate_trainer_threaded" class="menu">cross_validate_trainer_threaded</a></li><li><a href="#equal_error_rate" class="menu">equal_error_rate</a></li><li><a href="#test_assignment_function" class="menu">test_assignment_function</a></li><li><a href="#test_binary_decision_function" class="menu">test_binary_decision_function</a></li><li><a href="#test_graph_labeling_function" class="menu">test_graph_labeling_function</a></li><li><a href="#test_multiclass_decision_function" class="menu">test_multiclass_decision_function</a></li><li><a href="#test_object_detection_function" class="menu">test_object_detection_function</a></li><li><a href="#test_ranking_function" class="menu">test_ranking_function</a></li><li><a href="#test_regression_function" class="menu">test_regression_function</a></li><li><a href="#test_sequence_labeler" class="menu">test_sequence_labeler</a></li><li><a href="#test_sequence_segmenter" class="menu">test_sequence_segmenter</a></li><li><a href="#test_shape_predictor" class="menu">test_shape_predictor</a></li><li><a href="#test_track_association_function" class="menu">test_track_association_function</a></li></ul><br><b>Trainer Adapters</b><ul class="tree"><li><a href="#batch" class="menu">batch</a></li><li><a href="#batch_cached" class="menu">batch_cached</a></li><li><a href="#null_trainer" class="menu">null_trainer</a></li><li><a href="#probabilistic" class="menu">probabilistic</a></li><li><a href="#reduced" class="menu">reduced</a></li><li><a href="#reduced2" class="menu">reduced2</a></li><li><a href="#roc_c1_trainer" class="menu">roc_c1_trainer</a></li><li><a href="#roc_c2_trainer" class="menu">roc_c2_trainer</a></li><li><a href="#verbose_batch" class="menu">verbose_batch</a></li><li><a href="#verbose_batch_cached" class="menu">verbose_batch_cached</a></li></ul><br><b>Kernels</b><ul class="tree"><li><a href="#histogram_intersection_kernel" class="menu">histogram_intersection_kernel</a></li><li><a href="#linear_kernel" class="menu">linear_kernel</a></li><li><a href="#offset_kernel" class="menu">offset_kernel</a></li><li><a href="#polynomial_kernel" class="menu">polynomial_kernel</a></li><li><a href="#radial_basis_kernel" class="menu">radial_basis_kernel</a></li><li><a href="#sigmoid_kernel" class="menu">sigmoid_kernel</a></li><li><a href="#sparse_histogram_intersection_kernel" class="menu">sparse_histogram_intersection_kernel</a></li><li><a href="#sparse_linear_kernel" class="menu">sparse_linear_kernel</a></li><li><a href="#sparse_polynomial_kernel" class="menu">sparse_polynomial_kernel</a></li><li><a href="#sparse_radial_basis_kernel" class="menu">sparse_radial_basis_kernel</a></li><li><a href="#sparse_sigmoid_kernel" class="menu">sparse_sigmoid_kernel</a></li></ul><br><b>Function Objects</b><ul class="tree"><li><a href="#assignment_function" class="menu">assignment_function</a></li><li><a href="#decision_function" class="menu">decision_function</a></li><li><a href="#distance_function" class="menu">distance_function</a></li><li><a href="#graph_labeler" class="menu">graph_labeler</a></li><li><a href="#multiclass_linear_decision_function" class="menu">multiclass_linear_decision_function</a></li><li><a href="#normalized_function" class="menu">normalized_function</a></li><li><a href="#one_vs_all_decision_function" class="menu">one_vs_all_decision_function</a></li><li><a href="#one_vs_one_decision_function" class="menu">one_vs_one_decision_function</a></li><li><a href="#policy" class="menu">policy</a></li><li><a href="#probabilistic_decision_function" class="menu">probabilistic_decision_function</a></li><li><a href="#probabilistic_function" class="menu">probabilistic_function</a></li><li><a href="#projection_function" class="menu">projection_function</a></li><li><a href="#sequence_labeler" class="menu">sequence_labeler</a></li><li><a href="#sequence_segmenter" class="menu">sequence_segmenter</a></li><li><a href="#track_association_function" class="menu">track_association_function</a></li></ul><br><b>Data IO</b><ul class="tree"><li><a href="#fix_nonzero_indexing" class="menu">fix_nonzero_indexing</a></li><li><a href="#load_image_dataset" class="menu">load_image_dataset</a></li><li><a href="#load_image_dataset_metadata" class="menu">load_image_dataset_metadata</a></li><li><a href="#load_libsvm_formatted_data" class="menu">load_libsvm_formatted_data</a></li><li><a href="#save_image_dataset_metadata" class="menu">save_image_dataset_metadata</a></li><li><a href="#save_libsvm_formatted_data" class="menu">save_libsvm_formatted_data</a></li></ul><br><b>Miscellaneous</b><ul class="tree"><li><a href="#approximate_distance_function" class="menu">approximate_distance_function</a></li><li><a href="#compute_mean_squared_distance" class="menu">compute_mean_squared_distance</a></li><li><a href="#count_ranking_inversions" class="menu">count_ranking_inversions</a></li><li><a href="#fill_lisf" class="menu">fill_lisf</a></li><li><a href="#find_gamma_with_big_centroid_gap" class="menu">find_gamma_with_big_centroid_gap</a></li><li><a href="#is_assignment_problem" class="menu">is_assignment_problem</a></li><li><a href="#is_binary_classification_problem" class="menu">is_binary_classification_problem</a></li><li><a href="#is_forced_assignment_problem" class="menu">is_forced_assignment_problem</a></li><li><a href="#is_graph_labeling_problem" class="menu">is_graph_labeling_problem</a></li><li><a href="#is_learning_problem" class="menu">is_learning_problem</a></li><li><a href="#is_ranking_problem" class="menu">is_ranking_problem</a></li><li><a href="#is_sequence_labeling_problem" class="menu">is_sequence_labeling_problem</a></li><li><a href="#is_sequence_segmentation_problem" class="menu">is_sequence_segmentation_problem</a></li><li><a href="#is_track_association_problem" class="menu">is_track_association_problem</a></li><li><a href="#kernel_matrix" class="menu">kernel_matrix</a></li><li><a href="#learn_platt_scaling" class="menu">learn_platt_scaling</a></li><li><a href="#process_sample" class="menu">process_sample</a></li><li><a href="#randomize_samples" class="menu">randomize_samples</a></li><li><a href="#ranking_pair" class="menu">ranking_pair</a></li><li><a href="#select_all_distinct_labels" class="menu">select_all_distinct_labels</a></li><li><a href="#simplify_linear_decision_function" class="menu">simplify_linear_decision_function</a></li></ul><br></div><div class="menu_footer"></div></div></div><div id="bottom_content"><a name="add_layer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">add_layer</h1><BR><BR>
            In dlib, a deep neural network is composed of 3 main parts.  An 
            <a href="dlib/dnn/input_abstract.h.html#EXAMPLE_INPUT_LAYER">input layer</a>, a bunch of 
            <a href="dlib/dnn/layers_abstract.h.html#EXAMPLE_COMPUTATIONAL_LAYER_">computational layers</a>, 
            and optionally a 
            <a href="dlib/dnn/loss_abstract.h.html#EXAMPLE_LOSS_LAYER_">loss layer</a>.  The add_layer
            class is the central object which adds a computational layer onto an 
            input layer or an entire network.  Therefore, deep neural networks are created
            by stacking many layers on top of each other using the add_layer class.
            <p>
               For a tutorial showing how this is accomplished read 
               the <a href="dnn_introduction_ex.cpp.html">DNN Introduction part 1</a> and
               <a href="dnn_introduction2_ex.cpp.html">DNN Introduction part 2</a>.
            </p><BR><BR>C++ Example Programs: <a href="dnn_introduction_ex.cpp.html">dnn_introduction_ex.cpp</a>,
               <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a>,
               <a href="dnn_inception_ex.cpp.html">dnn_inception_ex.cpp</a>,
               <a href="dnn_imagenet_ex.cpp.html">dnn_imagenet_ex.cpp</a>,
               <a href="dnn_imagenet_train_ex.cpp.html">dnn_imagenet_train_ex.cpp</a>,
               <a href="dnn_mmod_ex.cpp.html">dnn_mmod_ex.cpp</a>,
               <a href="dnn_mmod_find_cars_ex.cpp.html">dnn_mmod_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_train_find_cars_ex.cpp.html">dnn_mmod_train_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_face_detection_ex.cpp.html">dnn_mmod_face_detection_ex.cpp</a>,
               <a href="dnn_mmod_dog_hipsterizer.cpp.html">dnn_mmod_dog_hipsterizer.cpp</a>,
               <a href="dnn_metric_learning_ex.cpp.html">dnn_metric_learning_ex.cpp</a>,
               <a href="dnn_metric_learning_on_images_ex.cpp.html">dnn_metric_learning_on_images_ex.cpp</a>,
               <a href="dnn_face_recognition_ex.cpp.html">dnn_face_recognition_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/core_abstract.h.html#add_layer">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="add_loss_layer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">add_loss_layer</h1><BR><BR>
            This object is a tool for stacking a <a href="dlib/dnn/loss_abstract.h.html#EXAMPLE_LOSS_LAYER_">loss layer</a> 
            on the top of a deep neural network.
         <BR><BR>C++ Example Programs: <a href="dnn_introduction_ex.cpp.html">dnn_introduction_ex.cpp</a>,
               <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a>,
               <a href="dnn_inception_ex.cpp.html">dnn_inception_ex.cpp</a>,
               <a href="dnn_imagenet_ex.cpp.html">dnn_imagenet_ex.cpp</a>,
               <a href="dnn_imagenet_train_ex.cpp.html">dnn_imagenet_train_ex.cpp</a>,
               <a href="dnn_mmod_ex.cpp.html">dnn_mmod_ex.cpp</a>,
               <a href="dnn_mmod_find_cars_ex.cpp.html">dnn_mmod_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_train_find_cars_ex.cpp.html">dnn_mmod_train_find_cars_ex.cpp</a>,
               <a href="dnn_metric_learning_ex.cpp.html">dnn_metric_learning_ex.cpp</a>,
               <a href="dnn_metric_learning_on_images_ex.cpp.html">dnn_metric_learning_on_images_ex.cpp</a>,
               <a href="dnn_face_recognition_ex.cpp.html">dnn_face_recognition_ex.cpp</a>,
               <a href="dnn_mmod_face_detection_ex.cpp.html">dnn_mmod_face_detection_ex.cpp</a>,
               <a href="dnn_mmod_dog_hipsterizer.cpp.html">dnn_mmod_dog_hipsterizer.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/core_abstract.h.html#add_loss_layer">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="add_skip_layer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">add_skip_layer</h1><BR><BR>
            This object adds a new layer to a deep neural network which draws its input
            from a <a href="#add_tag_layer">tagged layer</a> rather than from
            the immediate predecessor layer as is normally done.

            <p>
               For a tutorial showing how to use tagging see the 
               <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a>
               example program.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/core_abstract.h.html#add_skip_layer">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="add_tag_layer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">add_tag_layer</h1><BR><BR>
            This object is a tool for tagging layers in a deep neural network.  These tags make it
            easy to refer to the tagged layer in other parts of your code.
            Specifically, this object adds a new layer onto a deep neural network.
            However, this layer simply performs the identity transform.
            This means it is a no-op and its presence does not change the
            behavior of the network.  It exists solely to be used by <a href="#add_skip_layer">add_skip_layer</a> or <a href="#layer">layer()</a> to reference a
            particular part of a network.

            <p>
               For a tutorial showing how to use tagging see the 
               <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a>
               example program.
            </p><BR><BR>C++ Example Programs: <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/core_abstract.h.html#add_tag_layer">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="alias_tensor"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">alias_tensor</h1><BR><BR>
            This object is a <a href="#resizable_tensor">tensor</a> that
            aliases another tensor.  That is, it doesn't have its own block of
            memory but instead simply holds pointers to the memory of another
            tensor object.  It therefore allows you to efficiently break a tensor
            into pieces and pass those pieces into functions.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/tensor_abstract.h.html#alias_tensor">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="approximate_distance_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">approximate_distance_function</h1><BR><BR>
              This function attempts to find a <a href="#distance_function">distance_function</a> object which is close
              to a target distance_function.  That is, it searches for an X such that target(X) is
              minimized.  Critically, X may be set to use fewer basis vectors than the target.   

              <p>The optimization begins with an initial guess supplied by the user 
              and searches for an X which locally minimizes target(X).  Since
              this problem can have many local minima the quality of the starting point
              can significantly influence the results.   </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/reduced_abstract.h.html#approximate_distance_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="assignment_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">assignment_function</h1><BR><BR>
                This object is a tool for solving the optimal assignment problem given a 
                user defined method for computing the quality of any particular assignment. 
         <BR><BR>C++ Example Programs: <a href="assignment_learning_ex.cpp.html">assignment_learning_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/assignment_function_abstract.h.html#assignment_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="average_precision"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">average_precision</h1><BR><BR>
            This function computes the average precision of a ranking.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/average_precision_abstract.h.html#average_precision">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="batch"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">batch</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects.
         <BR><BR>C++ Example Programs: <a href="svm_pegasos_ex.cpp.html">svm_pegasos_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/pegasos_abstract.h.html#batch">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="batch_cached"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">batch_cached</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects that are setup
            to use a kernel matrix cache.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/pegasos_abstract.h.html#batch_cached">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="batch_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">batch_trainer</h1><BR><BR>
               This is a batch trainer object that is meant to wrap online trainer objects 
               that create <a href="#decision_function">decision_functions</a>.  It
               turns an online learning algorithm such as <a href="#svm_pegasos">svm_pegasos</a>
               into a batch learning object.  This allows you to use objects like
               svm_pegasos with functions (e.g. <a href="#cross_validate_trainer">cross_validate_trainer</a>)
               that expect batch mode training objects. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/pegasos_abstract.h.html#batch_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="bottom_up_cluster"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">bottom_up_cluster</h1><BR><BR>
             This function runs a bottom up agglomerative clustering algorithm.   
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/clustering/bottom_up_cluster_abstract.h.html#bottom_up_cluster">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="cca"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cca</h1><BR><BR>
              This function performs a canonical correlation analysis between two sets
              of vectors.  Additionally, it is designed to be very fast, even for large
              datasets of over a million high dimensional vectors.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/cca_abstract.h.html#cca">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="chinese_whispers"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">chinese_whispers</h1><BR><BR>
             This function performs the clustering algorithm described in the paper
             <blockquote>Chinese Whispers - an Efficient Graph Clustering Algorithm and its
              Application to Natural Language Processing Problems by Chris Biemann.</blockquote> 
             In particular, this is a method for automatically clustering the nodes in a
             graph into groups.  The method is able to automatically determine the number
             of clusters.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/clustering/chinese_whispers_abstract.h.html#chinese_whispers">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="compute_lda_transform"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">compute_lda_transform</h1><BR><BR>
            This function performs the dimensionality reducing version of linear
            discriminant analysis.  That is, you give it a set of labeled vectors and it
            returns a linear transform that maps the input vectors into a new space that
            is good for distinguishing between the different classes. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/lda_abstract.h.html#compute_lda_transform">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="compute_mean_squared_distance"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">compute_mean_squared_distance</h1><BR><BR>
            This is a function that simply finds the average squared distance between all
            pairs of a set of data samples.  It is often convenient to use the reciprocal
            of this value as the estimate of the gamma parameter of the 
            <a href="#radial_basis_kernel">radial_basis_kernel</a>.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/feature_ranking_abstract.h.html#compute_mean_squared_distance">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="compute_roc_curve"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">compute_roc_curve</h1><BR><BR>
            This function computes a ROC curve (receiver operating characteristic curve). 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/lda_abstract.h.html#compute_roc_curve">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="count_ranking_inversions"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">count_ranking_inversions</h1><BR><BR>
            Given two sets of objects, X and Y, and an ordering relationship defined
            between their elements, this function counts how many times we see an element
            in the set Y ordered before an element in the set X.   Additionally, this
            routine executes efficiently in O(n*log(n)) time via the use of quick sort.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/ranking_tools_abstract.h.html#count_ranking_inversions">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_assignment_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_assignment_trainer</h1><BR><BR>
            Performs k-fold cross validation on a user supplied assignment trainer object such
            as the <a href="#structural_assignment_trainer">structural_assignment_trainer</a>
            and returns the fraction of assignments predicted correctly.
         <BR><BR>C++ Example Programs: <a href="assignment_learning_ex.cpp.html">assignment_learning_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_assignment_trainer_abstract.h.html#cross_validate_assignment_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_graph_labeling_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_graph_labeling_trainer</h1><BR><BR>
            Performs k-fold cross validation on a user supplied graph labeling trainer object such
            as the <a href="#structural_graph_labeling_trainer">structural_graph_labeling_trainer</a>
            and returns the fraction of assignments predicted correctly.
         <BR><BR>C++ Example Programs: <a href="graph_labeling_ex.cpp.html">graph_labeling_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_graph_labeling_trainer_abstract.h.html#cross_validate_graph_labeling_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="cross_validate_multiclass_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_multiclass_trainer</h1><BR><BR>
            Performs k-fold cross validation on a user supplied multiclass classification trainer object such
            as the <a href="#one_vs_one_trainer">one_vs_one_trainer</a>.  The result is described by a 
            confusion matrix.
         <BR><BR>C++ Example Programs: <a href="multiclass_classification_ex.cpp.html">multiclass_classification_ex.cpp</a>,
               <a href="custom_trainer_ex.cpp.html">custom_trainer_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_multiclass_trainer_abstract.h.html#cross_validate_multiclass_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_object_detection_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_object_detection_trainer</h1><BR><BR>
            Performs k-fold cross validation on a user supplied object detection trainer such
            as the <a href="#structural_object_detection_trainer">structural_object_detection_trainer</a> 
            and returns the precision and recall. 
         <BR><BR>C++ Example Programs: <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="object_detector_advanced_ex.cpp.html">object_detector_advanced_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_object_detection_trainer_abstract.h.html#cross_validate_object_detection_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_ranking_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_ranking_trainer</h1><BR><BR>
            Performs k-fold cross validation on a user supplied ranking trainer object such
            as the <a href="#svm_rank_trainer">svm_rank_trainer</a>
            and returns the fraction of ranking pairs ordered correctly as well as the mean
            average precision. 
         <BR><BR>C++ Example Programs: <a href="svm_rank_ex.cpp.html">svm_rank_ex.cpp</a><BR>Python Example Programs: <a href="svm_rank.py.html">svm_rank.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/ranking_tools_abstract.h.html#cross_validate_ranking_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_regression_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_regression_trainer</h1><BR><BR>
            Performs k-fold cross validation on a user supplied regression trainer object such
            as the <a href="#svr_trainer">svr_trainer</a> and returns the mean squared error
            and R-squared value.
         <BR><BR>C++ Example Programs: <a href="svr_ex.cpp.html">svr_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_regression_trainer_abstract.h.html#cross_validate_regression_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_sequence_labeler"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_sequence_labeler</h1><BR><BR>
            Performs k-fold cross validation on a user supplied sequence labeling trainer object such
            as the <a href="#structural_sequence_labeling_trainer">structural_sequence_labeling_trainer</a>
            and returns a confusion matrix describing the results.
         <BR><BR>C++ Example Programs: <a href="sequence_labeler_ex.cpp.html">sequence_labeler_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_sequence_labeler_abstract.h.html#cross_validate_sequence_labeler">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_sequence_segmenter"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_sequence_segmenter</h1><BR><BR>
            Performs k-fold cross validation on a user supplied sequence segmentation trainer object such
            as the <a href="#structural_sequence_segmentation_trainer">structural_sequence_segmentation_trainer</a>
            and returns the resulting precision, recall, and F1-score. 
         <BR><BR>C++ Example Programs: <a href="sequence_segmenter_ex.cpp.html">sequence_segmenter_ex.cpp</a><BR>Python Example Programs: <a href="sequence_segmenter.py.html">sequence_segmenter.py</a>,
               <div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_sequence_segmenter_abstract.h.html#cross_validate_sequence_segmenter">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_track_association_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_track_association_trainer</h1><BR><BR>
            Performs k-fold cross validation on a user supplied track association trainer object such
            as the <a href="#structural_track_association_trainer">structural_track_association_trainer</a>
            and returns the fraction of detections which were correctly associated to their tracks.
         <BR><BR>C++ Example Programs: <a href="learning_to_track_ex.cpp.html">learning_to_track_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_track_association_trainer_abstract.h.html#cross_validate_track_association_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="cross_validate_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_trainer</h1><BR><BR>
               Performs k-fold cross validation on a user supplied binary classification trainer object such
               as the <a href="#svm_nu_trainer">svm_nu_trainer</a> or <a href="#rbf_network_trainer">rbf_network_trainer</a>.
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a>,
               <a href="model_selection_ex.cpp.html">model_selection_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#cross_validate_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="cross_validate_trainer_threaded"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">cross_validate_trainer_threaded</h1><BR><BR>
               Performs k-fold cross validation on a user supplied binary classification trainer object such
               as the <a href="#svm_nu_trainer">svm_nu_trainer</a> or <a href="#rbf_network_trainer">rbf_network_trainer</a>.  
               This function does the same thing as <a href="#cross_validate_trainer">cross_validate_trainer</a>
               except this function also allows you to specify how many threads of execution to use.
               So you can use this function to take advantage of a multi-core system to perform
               cross validation faster.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_threaded_abstract.h.html#cross_validate_trainer_threaded">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">decision_function</h1><BR><BR>
                This object represents a classification or regression function that was 
                learned by a kernel based learning algorithm.  Therefore, it is a function 
                object that takes a sample object and returns a scalar value.
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/function_abstract.h.html#decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="discriminant_pca"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">discriminant_pca</h1><BR><BR>
                This object implements the Discriminant PCA technique described in the paper:
                  <blockquote>
                    A New Discriminant Principal Component Analysis Method with Partial Supervision (2009)
                    by Dan Sun and Daoqiang Zhang
                  </blockquote>
                This algorithm is basically a straightforward generalization of the classical PCA
                technique to handle partially labeled data.  It is useful if you want to learn a linear
                dimensionality reduction rule using a bunch of data that is partially labeled.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/dpca_abstract.h.html#discriminant_pca">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="distance_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">distance_function</h1><BR><BR>
                This object represents a point in kernel induced feature space. 
                You may use this object to find the distance from the point it 
                represents to points in input space as well as other points
                represented by distance_functions.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/function_abstract.h.html#distance_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="dnn_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">dnn_trainer</h1><BR><BR>
            This object is a tool training a deep neural network. 
            <p>
               For a tutorial showing how this is accomplished read 
               the <a href="dnn_introduction_ex.cpp.html">DNN Introduction part 1</a> and
               <a href="dnn_introduction2_ex.cpp.html">DNN Introduction part 2</a>.
            </p><BR><BR>C++ Example Programs: <a href="dnn_introduction_ex.cpp.html">dnn_introduction_ex.cpp</a>,
               <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a>,
               <a href="dnn_inception_ex.cpp.html">dnn_inception_ex.cpp</a>,
               <a href="dnn_imagenet_ex.cpp.html">dnn_imagenet_ex.cpp</a>,
               <a href="dnn_imagenet_train_ex.cpp.html">dnn_imagenet_train_ex.cpp</a>,
               <a href="dnn_mmod_ex.cpp.html">dnn_mmod_ex.cpp</a>,
               <a href="dnn_mmod_find_cars_ex.cpp.html">dnn_mmod_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_train_find_cars_ex.cpp.html">dnn_mmod_train_find_cars_ex.cpp</a>,
               <a href="dnn_metric_learning_ex.cpp.html">dnn_metric_learning_ex.cpp</a>,
               <a href="dnn_metric_learning_on_images_ex.cpp.html">dnn_metric_learning_on_images_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/trainer_abstract.h.html#dnn_trainer">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="empirical_kernel_map"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">empirical_kernel_map</h1><BR><BR><p>
                This object represents a map from objects of sample_type (the kind of object 
                a <a href="dlib/svm/kernel_abstract.h.html#Kernel_Function_Objects">kernel function</a> 
                operates on) to finite dimensional column vectors which 
                represent points in the kernel feature space defined by whatever kernel 
                is used with this object. 
            </p><p>
                To use the empirical_kernel_map you supply it with a particular kernel and a set of 
                basis samples.  After that you can present it with new samples and it will project 
                them into the part of kernel feature space spanned by your basis samples.   
            </p><p>
                This means the empirical_kernel_map is a tool you can use to very easily kernelize 
                any algorithm that operates on column vectors.  All you have to do is select a 
                set of basis samples and then use the empirical_kernel_map to project all your 
                data points into the part of kernel feature space spanned by those basis samples.
                Then just run your normal algorithm on the output vectors and it will be effectively 
                kernelized.  
            </p><p>
                Regarding methods to select a set of basis samples, if you are working with only a 
                few thousand samples then you can just use all of them as basis samples.  
                Alternatively, the 
                <a href="#linearly_independent_subset_finder">linearly_independent_subset_finder</a> 
                often works well for selecting a basis set.  I also find that picking a 
                <a href="algorithms.html#random_subset_selector">random subset</a> typically works well.
            </p><BR><BR>C++ Example Programs: <a href="empirical_kernel_map_ex.cpp.html">empirical_kernel_map_ex.cpp</a>,
               <a href="linear_manifold_regularizer_ex.cpp.html">linear_manifold_regularizer_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/empirical_kernel_map_abstract.h.html#empirical_kernel_map">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="equal_error_rate"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">equal_error_rate</h1><BR><BR>
              This function finds a threshold that best separates the elements of two
              vectors by selecting the threshold with equal error rate.  It also reports
              the value of the equal error rate.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/lda_abstract.h.html#equal_error_rate">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="fill_lisf"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">fill_lisf</h1><BR><BR>
               This is a simple function for filling a 
               <a href="#linearly_independent_subset_finder">linearly_independent_subset_finder</a>
               with data points by using random sampling.   
         <BR><BR>C++ Example Programs: <a href="empirical_kernel_map_ex.cpp.html">empirical_kernel_map_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/linearly_independent_subset_finder_abstract.h.html#fill_lisf">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="find_clusters_using_angular_kmeans"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_clusters_using_angular_kmeans</h1><BR><BR>
            This is a simple linear kmeans clustering implementation.
            To compare a sample to a cluster, it measures the angle between them
            with respect to the origin.  Therefore, it tries to find clusters
            of points that all have small angles between each cluster member.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kkmeans_abstract.h.html#find_clusters_using_angular_kmeans">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="find_clusters_using_kmeans"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_clusters_using_kmeans</h1><BR><BR>
            This is a simple linear kmeans clustering implementation.
            It uses Euclidean distance to compare samples.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kkmeans_abstract.h.html#find_clusters_using_kmeans">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="find_gamma_with_big_centroid_gap"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">find_gamma_with_big_centroid_gap</h1><BR><BR>
            This is a function that tries to pick a reasonable default value for the
            gamma parameter of the <a href="#radial_basis_kernel">radial_basis_kernel</a>.  It
            picks the parameter that gives the largest separation between the centroids, in 
            kernel feature space, of two classes of data.
         <BR><BR>C++ Example Programs: <a href="rank_features_ex.cpp.html">rank_features_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/feature_ranking_abstract.h.html#find_gamma_with_big_centroid_gap">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="fix_nonzero_indexing"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">fix_nonzero_indexing</h1><BR><BR>
            This is a simple function that takes a std::vector of 
            <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a> 
            and makes sure they are zero-indexed (e.g. makes sure the first index value is zero).   
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/data_io/libsvm_io_abstract.h.html#fix_nonzero_indexing">More Details...</a><div class="include_file">#include &lt;dlib/data_io.h&gt;</div></div></div><a name="graph_labeler"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">graph_labeler</h1><BR><BR>
            This object is a tool for labeling each node in a <a href="containers.html#graph">graph</a> 
            with a value of true or false, subject to a labeling consistency constraint between 
            nodes that share an edge.  In particular, this object is useful for 
            representing a graph labeling model learned via some machine learning 
            method, such as the <a href="#structural_graph_labeling_trainer">structural_graph_labeling_trainer</a>.
         <BR><BR>C++ Example Programs: <a href="graph_labeling_ex.cpp.html">graph_labeling_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/graph_cuts/graph_labeler_abstract.h.html#graph_labeler">More Details...</a><div class="include_file">#include &lt;dlib/graph_cuts.h&gt;</div></div></div><a name="histogram_intersection_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">histogram_intersection_kernel</h1><BR><BR>
                This object represents a histogram intersection kernel for use with
                kernel learning machines.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kernel_abstract.h.html#histogram_intersection_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="input"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">input</h1><BR><BR>
            This is a simple input layer type for use in a deep neural network which
            takes some kind of image as input and loads it into a network.
         <BR><BR>C++ Example Programs: <a href="dnn_introduction_ex.cpp.html">dnn_introduction_ex.cpp</a>,
               <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a>,
               <a href="dnn_inception_ex.cpp.html">dnn_inception_ex.cpp</a>,
               <a href="dnn_imagenet_ex.cpp.html">dnn_imagenet_ex.cpp</a>,
               <a href="dnn_imagenet_train_ex.cpp.html">dnn_imagenet_train_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/input_abstract.h.html#input">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="input_rgb_image"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">input_rgb_image</h1><BR><BR>
            This is a simple input layer type for use in a deep neural network
            which takes an RGB image as input and loads it into a network.  It
            is very similar to the <a href="#input">input layer</a> except that
            it allows you to subtract the average color value from each color
            channel when converting an image to a tensor.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/input_abstract.h.html#input_rgb_image">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="input_rgb_image_pyramid"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">input_rgb_image_pyramid</h1><BR><BR>
            This input layer works with RGB images of type <tt>matrix&lt;rgb_pixel&gt;</tt>.  It is
            identical to <a href="#input_rgb_image">input_rgb_image</a> except that it
            outputs a tensor containing a <a href="imaging.html#create_tiled_pyramid">tiled image pyramid</a> 
            of each input image rather than a simple copy of each image.  
            This input layer is meant to be used with a loss layer such as the <a href="#loss_mmod_">MMOD loss layer</a>.
         <BR><BR>C++ Example Programs: <a href="dnn_mmod_ex.cpp.html">dnn_mmod_ex.cpp</a>,
               <a href="dnn_mmod_find_cars_ex.cpp.html">dnn_mmod_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_train_find_cars_ex.cpp.html">dnn_mmod_train_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_face_detection_ex.cpp.html">dnn_mmod_face_detection_ex.cpp</a>,
               <a href="dnn_mmod_dog_hipsterizer.cpp.html">dnn_mmod_dog_hipsterizer.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/input_abstract.h.html#input_rgb_image_pyramid">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="input_rgb_image_sized"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">input_rgb_image_sized</h1><BR><BR>
            This layer has an interface and behavior identical to <a href="#input_rgb_image">input_rgb_image</a>
            except that it requires input images to have a particular size. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/input_abstract.h.html#input_rgb_image_sized">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="is_assignment_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_assignment_problem</h1><BR><BR>
            This function takes a set of training data for an assignment problem
            and reports back if it could possibly be a well formed assignment problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#is_assignment_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="is_binary_classification_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_binary_classification_problem</h1><BR><BR>
             This function simply takes two vectors, the first containing feature vectors and
             the second containing labels, and reports back if the two could possibly 
             contain data for a well formed classification problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#is_binary_classification_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="is_forced_assignment_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_forced_assignment_problem</h1><BR><BR>
            This function takes a set of training data for a forced assignment problem
            and reports back if it could possibly be a well formed forced assignment problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#is_forced_assignment_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="is_graph_labeling_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_graph_labeling_problem</h1><BR><BR>
            This function takes a set of training data for a graph labeling problem
            and reports back if it could possibly be a well formed problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_graph_labeling_problem_abstract.h.html#is_graph_labeling_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="is_learning_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_learning_problem</h1><BR><BR>
             This function simply takes two vectors, the first containing feature vectors and
             the second containing labels, and reports back if the two could possibly 
             contain data for a well formed learning problem.  In this case it just means
             that the two vectors have the same length and aren't empty.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#is_learning_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="is_ranking_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_ranking_problem</h1><BR><BR>
            This function takes a set of training data for a learning-to-rank problem
            and reports back if it could possibly be a well formed problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/ranking_tools_abstract.h.html#is_ranking_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="is_sequence_labeling_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_sequence_labeling_problem</h1><BR><BR>
            This function takes a set of training data for a sequence labeling problem
            and reports back if it could possibly be a well formed sequence labeling problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#is_sequence_labeling_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="is_sequence_segmentation_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_sequence_segmentation_problem</h1><BR><BR>
            This function takes a set of training data for a sequence segmentation problem
            and reports back if it could possibly be a well formed sequence segmentation problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#is_sequence_segmentation_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="is_track_association_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">is_track_association_problem</h1><BR><BR>
            This function takes a set of training data for a track association learning problem
            and reports back if it could possibly be a well formed track association problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#is_track_association_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="kcentroid"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">kcentroid</h1><BR><BR>

                This object represents a weighted sum of sample points in a kernel induced
                feature space.  It can be used to kernelize any algorithm that requires only
                the ability to perform vector addition, subtraction, scalar multiplication,
                and inner products.  

                  <p>
                An example use of this object is as an online algorithm for recursively estimating 
                the centroid of a sequence of training points.  This object then allows you to 
                compute the distance between the centroid and any test points.  So you can use 
                this object to predict how similar a test point is to the data this object has 
                been trained on (larger distances from the centroid indicate dissimilarity/anomalous 
                points).  
                  </p><p>
                The object internally keeps a set of "dictionary vectors" 
                that are used to represent the centroid.  It manages these vectors using the 
                sparsification technique described in the paper The Kernel Recursive Least 
                Squares Algorithm by Yaakov Engel.  This technique allows us to keep the 
                number of dictionary vectors down to a minimum.  In fact, the object has a 
                user selectable tolerance parameter that controls the trade off between 
                accuracy and number of stored dictionary vectors.
                  </p><BR><BR>C++ Example Programs: <a href="kcentroid_ex.cpp.html">kcentroid_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kcentroid_abstract.h.html#kcentroid">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="kernel_matrix"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">kernel_matrix</h1><BR><BR>
            This is a simple set of functions that makes it easy to turn a kernel 
            object and a set of samples into a kernel matrix.  It takes these two
            things and returns a <a href="dlib/matrix/matrix_exp_abstract.h.html#matrix_exp">matrix expression</a>
            that represents the kernel matrix.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kernel_matrix_abstract.h.html">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="kkmeans"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">kkmeans</h1><BR><BR>
                This is an implementation of a kernelized k-means clustering algorithm.  
                It performs k-means clustering by using the <a href="#kcentroid">kcentroid</a> object.  
                <p>
                   If you want to use the linear kernel (i.e. do a normal k-means clustering) then you
                   should use the <a href="#find_clusters_using_kmeans">find_clusters_using_kmeans</a> routine.
                </p><BR><BR>C++ Example Programs: <a href="kkmeans_ex.cpp.html">kkmeans_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kkmeans_abstract.h.html#kkmeans">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="krls"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">krls</h1><BR><BR>
                This is an implementation of the kernel recursive least squares algorithm 
                described in the paper The Kernel Recursive Least Squares Algorithm by Yaakov Engel.
            <p>
                The long and short of this algorithm is that it is an online kernel based 
                regression algorithm.  You give it samples (x,y) and it learns the function
                f(x) == y.  For a detailed description of the algorithm read the above paper.
            </p><p>
                  Note that if you want to use the linear kernel then you would
                  be better off using the <a href="#rls">rls</a> object as it
                  is optimized for this case.
               </p><BR><BR>C++ Example Programs: <a href="krls_ex.cpp.html">krls_ex.cpp</a>,
               <a href="krls_filter_ex.cpp.html">krls_filter_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/krls_abstract.h.html#krls">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="krr_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">krr_trainer</h1><BR><BR><p>
               Performs kernel ridge regression and outputs a <a href="#decision_function">decision_function</a> that 
               represents the learned function. 
            </p>
            The implementation is done using the <a href="#empirical_kernel_map">empirical_kernel_map</a> and 
            <a href="#linearly_independent_subset_finder">linearly_independent_subset_finder</a> to kernelize
            the <a href="#rr_trainer">rr_trainer</a> object.  Thus it allows you to run the algorithm on large 
            datasets and obtain sparse outputs.  It is also capable of automatically estimating its 
            regularization parameter using leave-one-out cross-validation.
         <BR><BR>C++ Example Programs: <a href="krr_regression_ex.cpp.html">krr_regression_ex.cpp</a>,
               <a href="krr_classification_ex.cpp.html">krr_classification_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/krr_trainer_abstract.h.html#krr_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="layer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">layer</h1><BR><BR>
            This global function references a <a href="#add_tag_layer">tagged layer</a> 
            inside a deep neural network object.

            <p>
               For a tutorial showing how to use tagging see the 
               <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a>
               example program.
            </p><BR><BR>C++ Example Programs: <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/core_abstract.h.html#layer">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="learn_platt_scaling"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">learn_platt_scaling</h1><BR><BR><p>
              This function is an implementation of the algorithm described in the following
              papers: 
              <blockquote>
                Probabilistic Outputs for Support Vector Machines and Comparisons to
                Regularized Likelihood Methods by John C. Platt.  March 26, 1999
                <br><br>
                A Note on Platt's Probabilistic Outputs for Support Vector Machines
                by Hsuan-Tien Lin, Chih-Jen Lin, and Ruby C. Weng
              </blockquote></p><p>
               This function is the tool used to implement the 
               <a href="#train_probabilistic_decision_function">train_probabilistic_decision_function</a> routine.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#learn_platt_scaling">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="linearly_independent_subset_finder"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">linearly_independent_subset_finder</h1><BR><BR><p>
                This is an implementation of an online algorithm for recursively finding a
                set (aka dictionary) of linearly independent vectors in a kernel induced 
                feature space.  To use it you decide how large you would like the dictionary 
                to be and then you feed it sample points.  
            </p><p>
                The implementation uses the Approximately Linearly Dependent metric described 
                in the paper The Kernel Recursive Least Squares Algorithm by Yaakov Engel to 
                decide which points are more linearly independent than others.  The metric is 
                simply the squared distance between a test point and the subspace spanned by 
                the set of dictionary vectors.
            </p><p>
                Each time you present this object with a new sample point  
                it calculates the projection distance and if it is sufficiently large then this 
                new point is included into the dictionary.  Note that this object can be configured 
                to have a maximum size.  Once the max dictionary size is reached each new point 
                kicks out a previous point.  This is done by removing the dictionary vector that 
                has the smallest projection distance onto the others.  That is, the "least linearly 
                independent" vector is removed to make room for the new one.
            </p><BR><BR>C++ Example Programs: <a href="empirical_kernel_map_ex.cpp.html">empirical_kernel_map_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/linearly_independent_subset_finder_abstract.h.html#linearly_independent_subset_finder">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="linear_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">linear_kernel</h1><BR><BR>
                This object represents a linear function kernel for use with
                kernel learning machines.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kernel_abstract.h.html#linear_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="linear_manifold_regularizer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">linear_manifold_regularizer</h1><BR><BR><p>
                Many learning algorithms attempt to minimize a function that, at a high 
                level, looks like this:   
<pre>
   f(w) == complexity + training_set_error
</pre></p><p>
                The idea is to find the set of parameters, w, that gives low error on 
                your training data but also is not "complex" according to some particular
                measure of complexity.  This strategy of penalizing complexity is 
                usually called regularization.
               </p><p>
                In the above setting, all the training data consists of labeled samples.  
                However, it would be nice to be able to benefit from unlabeled data.  
                The idea of manifold regularization is to extract useful information from 
                unlabeled data by first defining which data samples are "close" to each other 
                (perhaps by using their 3 <a href="graph_tools.html#find_k_nearest_neighbors">nearest neighbors</a>) 
                and then adding a term to 
                the above function that penalizes any decision rule which produces 
                different outputs on data samples which we have designated as being close.
               </p><p>
                It turns out that it is possible to transform these manifold regularized learning
                problems into the normal form shown above by applying a certain kind of 
                preprocessing to all our data samples.  Once this is done we can use a 
                normal learning algorithm, such as the <a href="#svm_c_linear_trainer">svm_c_linear_trainer</a>, 
                on just the
                labeled data samples and obtain the same output as the manifold regularized
                learner would have produced.  
               </p><p>
                The linear_manifold_regularizer is a tool for creating this preprocessing 
                transformation.  In particular, the transformation is linear.  That is, it 
                is just a matrix you multiply with all your samples.  For a more detailed 
                discussion of this topic you should consult the following paper.  In 
                particular, see section 4.2.  This object computes the inverse T matrix 
                described in that section.
               <blockquote>
                    Linear Manifold Regularization for Large Scale Semi-supervised Learning
                    by Vikas Sindhwani, Partha Niyogi, and Mikhail Belkin
               </blockquote></p><BR><BR>C++ Example Programs: <a href="linear_manifold_regularizer_ex.cpp.html">linear_manifold_regularizer_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/manifold_regularization/linear_manifold_regularizer_abstract.h.html#linear_manifold_regularizer">More Details...</a><div class="include_file">#include &lt;dlib/manifold_regularization.h&gt;</div></div></div><a name="load_image_dataset"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_image_dataset</h1><BR><BR>
            This is a function which loads the list of images indicated by an
            <a href="#load_image_dataset_metadata">image dataset metadata file</a>
            as well as the box locations for each image.  It makes loading the
            data necessary to train an <a href="imaging.html#object_detector">object_detector</a> 
            a little more convenient.
         <BR><BR>C++ Example Programs: <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/data_io/load_image_dataset_abstract.h.html#load_image_dataset">More Details...</a><div class="include_file">#include &lt;dlib/data_io.h&gt;</div></div></div><a name="load_image_dataset_metadata"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_image_dataset_metadata</h1><BR><BR>
            dlib comes with a graphical tool for annotating images with
            labeled rectangles.  The tool produces an XML file containing these
            annotations.  Therefore, load_image_dataset_metadata() is a routine
            for parsing these XML files.  Note also that this is the metadata
            format used by the image labeling tool included with dlib in the
            tools/imglab folder.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/data_io/image_dataset_metadata.h.html#load_image_dataset_metadata">More Details...</a><div class="include_file">#include &lt;dlib/data_io.h&gt;</div></div></div><a name="load_libsvm_formatted_data"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_libsvm_formatted_data</h1><BR><BR>
            This is a function that loads the data from a file that uses
            the LIBSVM format.  It loads the data into a std::vector of
            <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
            If you want to load data into dense vectors (i.e.
            dlib::matrix objects) then you can use the <a href="linear_algebra.html#sparse_to_dense">sparse_to_dense</a>
            function to perform the conversion.  Also, some LIBSVM formatted files number
            their features beginning with 1 rather than 0.  If this bothers you, then you
            can fix it by using the <a href="#fix_nonzero_indexing">fix_nonzero_indexing</a> function
            on the data after it is loaded.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/data_io/libsvm_io_abstract.h.html#load_libsvm_formatted_data">More Details...</a><div class="include_file">#include &lt;dlib/data_io.h&gt;</div></div></div><a name="load_mnist_dataset"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">load_mnist_dataset</h1><BR><BR>
            Loads the <a href="http://yann.lecun.com/exdb/mnist/">MNIST dataset</a> from disk.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/data_io/mnist_abstract.h.html">More Details...</a><div class="include_file">#include &lt;dlib/data_io.h&gt;</div></div></div><a name="loss_mean_squared_"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">loss_mean_squared_</h1><BR><BR>
            This object is a <a href="dlib/dnn/loss_abstract.h.html#EXAMPLE_LOSS_LAYER_">loss layer</a> 
            for a deep neural network. In particular, it implements the mean squared loss, which is
            appropriate for regression problems.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/loss_abstract.h.html#loss_mean_squared_">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="loss_mean_squared_multioutput_"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">loss_mean_squared_multioutput_</h1><BR><BR>
            This object is a <a href="dlib/dnn/loss_abstract.h.html#EXAMPLE_LOSS_LAYER_">loss layer</a> 
            for a deep neural network. In particular, it implements the mean squared loss, which is
            appropriate for regression problems.  It is identical to the <a href="#loss_mean_squared_">loss_mean_squared_</a> 
            loss except this version supports multiple output values.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/loss_abstract.h.html#loss_mean_squared_multioutput_">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="loss_metric_"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">loss_metric_</h1><BR><BR>
            This object is a <a href="dlib/dnn/loss_abstract.h.html#EXAMPLE_LOSS_LAYER_">loss layer</a> 
            for a deep neural network.   In particular, it allows you to learn to map objects
            into a vector space where objects sharing the same class label are close to
            each other, while objects with different labels are far apart.   
         <BR><BR>C++ Example Programs: <a href="dnn_metric_learning_ex.cpp.html">dnn_metric_learning_ex.cpp</a>,
               <a href="dnn_metric_learning_on_images_ex.cpp.html">dnn_metric_learning_on_images_ex.cpp</a>,
               <a href="dnn_face_recognition_ex.cpp.html">dnn_face_recognition_ex.cpp</a><BR>Python Example Programs: <a href="face_recognition.py.html">face_recognition.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/loss_abstract.h.html#loss_metric_">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="loss_mmod_"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">loss_mmod_</h1><BR><BR>
            This object is a <a href="dlib/dnn/loss_abstract.h.html#EXAMPLE_LOSS_LAYER_">loss layer</a> 
            for a deep neural network.  In particular, it implements the Max Margin Object Detection 
            loss defined in the paper:
            <blockquote><a href="http://arxiv.org/abs/1502.00046">Max-Margin Object Detection</a> by Davis E. King.</blockquote>
         
            This means you use this loss if you want to detect the locations of objects
            in images.  
         <BR><BR>C++ Example Programs: <a href="dnn_mmod_ex.cpp.html">dnn_mmod_ex.cpp</a>,
               <a href="dnn_mmod_find_cars_ex.cpp.html">dnn_mmod_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_train_find_cars_ex.cpp.html">dnn_mmod_train_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_face_detection_ex.cpp.html">dnn_mmod_face_detection_ex.cpp</a>,
               <a href="dnn_mmod_dog_hipsterizer.cpp.html">dnn_mmod_dog_hipsterizer.cpp</a><BR>Python Example Programs: <a href="cnn_face_detector.py.html">cnn_face_detector.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/loss_abstract.h.html#loss_mmod_">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="lspi"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">lspi</h1><BR><BR>
            This object is an implementation of the reinforcement learning algorithm
            described in the following paper:
            <blockquote>
               Lagoudakis, Michail G., and Ronald Parr. "Least-squares policy
               iteration." The Journal of Machine Learning Research 4 (2003):
               1107-1149.
            </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/control/lspi_abstract.h.html#lspi">More Details...</a><div class="include_file">#include &lt;dlib/control.h&gt;</div></div></div><a name="mlp"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">mlp</h1><BR><BR><p>
                This object represents a multilayer layer perceptron network that is
                trained using the back propagation algorithm.  The training algorithm also
                incorporates the momentum method.  That is, each round of back propagation
                training also adds a fraction of the previous update.  This fraction
                is controlled by the momentum term set in the constructor.  
            </p><p>
               It is worth noting that a MLP is, in general, very inferior to modern
               kernel algorithms such as the support vector machine.  So if you haven't
               tried any other techniques with your data you really should.  
            </p><BR><BR>C++ Example Programs: <a href="mlp_ex.cpp.html">mlp_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/mlp/mlp_kernel_abstract.h.html">More Details...</a><div class="include_file">#include &lt;dlib/mlp.h&gt;</div></div><BR><BR><B>Implementations:</B><blockquote><a href="dlib/mlp/mlp_kernel_1.h.html">mlp_kernel_1</a>:
                  <br> 
                  This is implemented in the obvious way.
               <div class="typedefs"><table CELLSPACING="0" CELLPADDING="0" bgcolor="white"><tr><td bgcolor="#E3E3E3" valign="top"><div class="tdn">kernel_1a</div></td><td width="100%" bgcolor="#E3E3E3">is a typedef for mlp_kernel_1</td></tr><tr><td valign="top"><div class="tdn">kernel_1a_c</div></td><td width="100%"> 
                  is a typedef for kernel_1a that checks its preconditions.             
                  </td></tr></table></div></blockquote></div><a name="modularity"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">modularity</h1><BR><BR>
            This function computes the modularity of a particular graph clustering.  This
            is a number that tells you how good the clustering is.  In particular, it 
            is the measure optimized by the <a href="#newman_cluster">newman_cluster</a> 
            routine.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/clustering/modularity_clustering_abstract.h.html#modularity">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="multiclass_linear_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">multiclass_linear_decision_function</h1><BR><BR>
                This object represents a multiclass classifier built out of a set of 
                binary classifiers.  Each binary classifier is used to vote for the 
                correct multiclass label using a one vs. all strategy.  Therefore, 
                if you have N classes then there will be N binary classifiers inside 
                this object.  Additionally, this object is linear in the sense that
                each of these binary classifiers is a simple linear plane.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/function_abstract.h.html#multiclass_linear_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="nearest_center"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">nearest_center</h1><BR><BR>
            This function takes a list of cluster centers and a query vector
            and identifies which cluster center is nearest to the query vector. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kkmeans_abstract.h.html#nearest_center">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="newman_cluster"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">newman_cluster</h1><BR><BR>
             This function performs the clustering algorithm described in the paper
             <blockquote>Modularity and community structure in networks by M. E. J. Newman.</blockquote> 
             In particular, this is a method for automatically clustering the nodes in a
             graph into groups.  The method is able to automatically determine the number
             of clusters and does not have any parameters.  In general, it is a very good
             clustering technique.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/clustering/modularity_clustering_abstract.h.html#newman_cluster">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="normalized_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">normalized_function</h1><BR><BR>
                This object represents a container for another function
                object and an instance of the <a href="#vector_normalizer">vector_normalizer</a> object.  

                It automatically normalizes all inputs before passing them
                off to the contained function object.
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/function_abstract.h.html#normalized_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="null_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">null_trainer</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#null_trainer_type">null_trainer_type</a>
            objects.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/null_trainer_abstract.h.html#null_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="null_trainer_type"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">null_trainer_type</h1><BR><BR>
                This object is a simple tool for turning a <a href="#decision_function">decision_function</a> 
                (or any object with an interface compatible with decision_function)
                into a trainer object that always returns the original decision
                function when you try to train with it.  

               <p>
                dlib contains a few "training post processing" algorithms (e.g. 
                <a href="#reduced">reduced</a> and <a href="#reduced2">reduced2</a>).  These tools 
                take in a trainer object,
                tell it to perform training, and then they take the output decision
                function and do some kind of post processing to it.  The null_trainer_type 
                object is useful because you can use it to run an already
                learned decision function through the training post processing
                algorithms by turning a decision function into a null_trainer_type
                and then giving it to a post processor.  
               </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/null_trainer_abstract.h.html#null_trainer_type">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="offset_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">offset_kernel</h1><BR><BR>
                This object represents a kernel with a fixed value offset
                added to it.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kernel_abstract.h.html#offset_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="one_vs_all_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">one_vs_all_decision_function</h1><BR><BR>
                This object represents a multiclass classifier built out
                of a set of binary classifiers.  Each binary classifier
                is used to vote for the correct multiclass label using a 
                one vs. all strategy.  Therefore, if you have N classes then
                there will be N binary classifiers inside this object.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/one_vs_all_decision_function_abstract.h.html#one_vs_all_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="one_vs_all_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">one_vs_all_trainer</h1><BR><BR>
                This object is a tool for turning a bunch of binary classifiers
                into a multiclass classifier.  It does this by training the binary
                classifiers in a one vs. all fashion.  That is, if you have N possible
                classes then it trains N binary classifiers which are then used
                to vote on the identity of a test sample.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/one_vs_all_trainer_abstract.h.html#one_vs_all_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="one_vs_one_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">one_vs_one_decision_function</h1><BR><BR>
                This object represents a multiclass classifier built out
                of a set of binary classifiers.  Each binary classifier
                is used to vote for the correct multiclass label using a 
                one vs. one strategy.  Therefore, if you have N classes then
                there will be N*(N-1)/2 binary classifiers inside this object.
         <BR><BR>C++ Example Programs: <a href="multiclass_classification_ex.cpp.html">multiclass_classification_ex.cpp</a>,
               <a href="custom_trainer_ex.cpp.html">custom_trainer_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/one_vs_one_decision_function_abstract.h.html#one_vs_one_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="one_vs_one_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">one_vs_one_trainer</h1><BR><BR>
                This object is a tool for turning a bunch of binary classifiers
                into a multiclass classifier.  It does this by training the binary
                classifiers in a one vs. one fashion.  That is, if you have N possible
                classes then it trains N*(N-1)/2 binary classifiers which are then used
                to vote on the identity of a test sample.
         <BR><BR>C++ Example Programs: <a href="multiclass_classification_ex.cpp.html">multiclass_classification_ex.cpp</a>,
               <a href="custom_trainer_ex.cpp.html">custom_trainer_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/one_vs_one_trainer_abstract.h.html#one_vs_one_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="pick_initial_centers"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">pick_initial_centers</h1><BR><BR>
            This is a function that you can use to seed data clustering algorithms
            like the <a href="#kkmeans">kkmeans</a> clustering method.  What it 
            does is pick reasonable starting points for clustering by basically
            trying to find a set of points that are all far away from each other.
         <BR><BR>C++ Example Programs: <a href="kkmeans_ex.cpp.html">kkmeans_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kkmeans_abstract.h.html#pick_initial_centers">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="policy"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">policy</h1><BR><BR>
                This is a policy (i.e. a control law) based on a linear function approximator.
                You can use a tool like <a href="#lspi">lspi</a> to learn the parameters
                of a policy.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/control/approximate_linear_models_abstract.h.html#policy">More Details...</a><div class="include_file">#include &lt;dlib/control.h&gt;</div></div></div><a name="polynomial_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">polynomial_kernel</h1><BR><BR>
                This object represents a polynomial kernel for use with
                kernel learning machines.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kernel_abstract.h.html#polynomial_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="probabilistic"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">probabilistic</h1><BR><BR>
            This is a trainer adapter which simply runs the trainer it is given though the
            <a href="#train_probabilistic_decision_function">train_probabilistic_decision_function</a>
            function.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#probabilistic">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="probabilistic_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">probabilistic_decision_function</h1><BR><BR>
                This object represents a binary decision function for use with
                kernel-based learning-machines.  It returns an 
                estimate of the probability that a given sample is in the +1 class. 
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/function_abstract.h.html#probabilistic_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="probabilistic_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">probabilistic_function</h1><BR><BR>
                This object represents a binary decision function for use with
                any kind of binary classifier.  It returns an 
                estimate of the probability that a given sample is in the +1 class. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/function_abstract.h.html#probabilistic_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="process_sample"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">process_sample</h1><BR><BR>
                This object holds a training sample for a reinforcement learning algorithm 
                (e.g. <a href="#lspi">lspi</a>).
                In particular, it contains a state, action, reward, next state sample from
                some process.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/control/approximate_linear_models_abstract.h.html#process_sample">More Details...</a><div class="include_file">#include &lt;dlib/control.h&gt;</div></div></div><a name="projection_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">projection_function</h1><BR><BR>
               This object represents a function that takes a data sample and projects
               it into kernel feature space.  The result is a real valued column vector that 
               represents a point in a kernel feature space.   Instances of
               this object are created using the 
               <a href="#empirical_kernel_map">empirical_kernel_map</a>.
         <BR><BR>C++ Example Programs: <a href="linear_manifold_regularizer_ex.cpp.html">linear_manifold_regularizer_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/function_abstract.h.html#projection_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="radial_basis_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">radial_basis_kernel</h1><BR><BR>
                This object represents a radial basis function kernel for use with
                kernel learning machines.
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kernel_abstract.h.html#radial_basis_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="randomize_samples"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">randomize_samples</h1><BR><BR>
               Randomizes the order of samples in a column vector containing sample data.
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#randomize_samples">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="ranking_pair"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">ranking_pair</h1><BR><BR>
                This object is used to contain a ranking example.  Therefore, ranking_pair
                objects are used to represent training examples for learning-to-rank tasks,
                such as those used by the <a href="#svm_rank_trainer">svm_rank_trainer</a>.
         <BR><BR>C++ Example Programs: <a href="svm_rank_ex.cpp.html">svm_rank_ex.cpp</a><BR>Python Example Programs: <a href="svm_rank.py.html">svm_rank.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/ranking_tools_abstract.h.html#ranking_pair">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="rank_features"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rank_features</h1><BR><BR>
             Finds a ranking of the top N (a user supplied parameter) features in a set of data 
             from a two class classification problem.  It  
              does this by computing the distance between the centroids of both classes in kernel defined 
              feature space.  Good features are then ones that result in the biggest separation between
              the two centroids. 
         <BR><BR>C++ Example Programs: <a href="rank_features_ex.cpp.html">rank_features_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/feature_ranking_abstract.h.html#rank_features">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="rank_unlabeled_training_samples"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rank_unlabeled_training_samples</h1><BR><BR>
            This routine implements an active learning method for selecting the most
            informative data sample to label out of a set of unlabeled samples. 
            In particular, it implements the MaxMin Margin and Ratio Margin methods 
            described in the paper:
            <blockquote>
                Support Vector Machine Active Learning with Applications to Text Classification
                by Simon Tong and Daphne Koller.
            </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/active_learning_abstract.h.html#rank_unlabeled_training_samples">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="rbf_network_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rbf_network_trainer</h1><BR><BR>
               Trains a radial basis function network and outputs a <a href="#decision_function">decision_function</a>. 
               This object can be used for either regression or binary classification problems.
               It's worth pointing out that this object is essentially an unregularized version 
               of <a href="#krr_trainer">kernel ridge regression</a>.  This means 
               you should really prefer to use kernel ridge regression instead.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/rbf_network_abstract.h.html#rbf_network_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="reduced"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">reduced</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#reduced_decision_function_trainer">reduced_decision_function_trainer</a>
            objects.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/reduced_abstract.h.html#reduced">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="reduced2"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">reduced2</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#reduced_decision_function_trainer2">reduced_decision_function_trainer2</a>
            objects.
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/reduced_abstract.h.html#reduced2">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="reduced_decision_function_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">reduced_decision_function_trainer</h1><BR><BR>
               This is a batch trainer object that is meant to wrap other batch trainer objects 
               that create <a href="#decision_function">decision_function</a> objects.
               It performs post processing on the output decision_function objects 
               with the intent of representing the decision_function with fewer 
               basis vectors.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/reduced_abstract.h.html#reduced_decision_function_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="reduced_decision_function_trainer2"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">reduced_decision_function_trainer2</h1><BR><BR><p>
               This is a batch trainer object that is meant to wrap other batch trainer objects 
               that create <a href="#decision_function">decision_function</a> objects.
               It performs post processing on the output decision_function objects 
               with the intent of representing the decision_function with fewer 
               basis vectors.  
               </p><p>
               It begins by performing the same post processing as
               the <a href="#reduced_decision_function_trainer">reduced_decision_function_trainer</a>
               object but it also performs a global gradient based optimization 
               to further improve the results.  The gradient based optimization is
               implemented using the <a href="#approximate_distance_function">approximate_distance_function</a> routine.
               </p><BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/reduced_abstract.h.html#reduced_decision_function_trainer2">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="repeat"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">repeat</h1><BR><BR>
            This object adds N copies of a computational layer onto a deep neural network. 
            It is essentially the same as using <a href="#add_layer">add_layer</a> N times, 
            except that it involves less typing, and for large N, will compile much faster.
         <BR><BR>C++ Example Programs: <a href="dnn_introduction2_ex.cpp.html">dnn_introduction2_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/core_abstract.h.html#repeat">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="resizable_tensor"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">resizable_tensor</h1><BR><BR>
               This object represents a 4D array of float values, all stored contiguously
               in memory.  Importantly, it keeps two copies of the floats, one on the host
               CPU side and another on the GPU device side. It automatically performs the
               necessary host/device transfers to keep these two copies of the data in
               sync.

               <p>
                All transfers to the device happen asynchronously with respect to the
                default CUDA stream so that CUDA kernel computations can overlap with data
                transfers.  However, any transfers from the device to the host happen
                synchronously in the default CUDA stream.  Therefore, you should perform
                all your CUDA kernel launches on the default stream so that transfers back
                to the host do not happen before the relevant computations have completed.
               </p><p>
                If DLIB_USE_CUDA is not #defined then this object will not use CUDA at all.
                Instead, it will simply store one host side memory block of floats.  
               </p><p>
                Finally, the convention in dlib code is to interpret the tensor as a set of
                num_samples() 3D arrays, each of dimension k() by nr() by nc().  Also,
                while this class does not specify a memory layout, the convention is to
                assume that indexing into an element at coordinates (sample,k,nr,nc) can be
                accomplished via:
                <tt>host()[((sample*t.k() + k)*t.nr() + nr)*t.nc() + nc]</tt></p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/tensor_abstract.h.html#resizable_tensor">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="rls"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rls</h1><BR><BR>
            This is an implementation of the linear version of the recursive least 
            squares algorithm.  It accepts training points incrementally and, at 
            each step, maintains the solution to the following optimization problem:
            <blockquote>
               find w minimizing: 0.5*dot(w,w) + C*sum_i(y_i - trans(x_i)*w)^2
            </blockquote>
            Where (x_i,y_i) are training pairs.  x_i is some vector and y_i is a target
            scalar value.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/rls_abstract.h.html#rls">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="roc_c1_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">roc_c1_trainer</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#roc_trainer_type">roc_trainer_type</a> objects that are
            setup to pick a point on the ROC curve with respect to the +1 class.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/roc_trainer_abstract.h.html#roc_c1_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="roc_c2_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">roc_c2_trainer</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#roc_trainer_type">roc_trainer_type</a> objects that are
            setup to pick a point on the ROC curve with respect to the -1 class.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/roc_trainer_abstract.h.html#roc_c2_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="roc_trainer_type"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">roc_trainer_type</h1><BR><BR>
                This object is a simple trainer post processor that allows you to 
                easily adjust the bias term in a trained decision_function object.
                That is, this object lets you pick a point on the ROC curve and 
                it will adjust the bias term appropriately.  

               <p>
                So for example, suppose you wanted to set the bias term so that
                the accuracy of your decision function on +1 labeled samples was 99%.
                To do this you would use an instance of this object declared as follows:
                <tt>roc_trainer_type&lt;trainer_type&gt;(your_trainer, 0.99, +1);</tt></p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/roc_trainer_abstract.h.html#roc_trainer_type">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="rr_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rr_trainer</h1><BR><BR><p>
               Performs linear ridge regression and outputs a <a href="#decision_function">decision_function</a> that 
               represents the learned function.  In particular, this object can only be used with
               the <a href="#linear_kernel">linear_kernel</a>.  It is optimized for the linear case where
               the number of features in each sample vector is small (i.e. on the order of 1000 or less since the 
               algorithm is cubic in the number of features.).  
               If you want to use a nonlinear kernel then you should use the <a href="#krr_trainer">krr_trainer</a>.
            </p>
              This object is capable of automatically estimating its regularization parameter using 
              leave-one-out cross-validation.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/rr_trainer_abstract.h.html#rr_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="rvm_regression_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rvm_regression_trainer</h1><BR><BR><p>
               Trains a relevance vector machine for solving regression problems.  
               Outputs a <a href="#decision_function">decision_function</a> that represents the learned 
               regression function. 
            </p>
               The implementation of the RVM training algorithm used by this library is based
               on the following paper:
               <blockquote>
                Tipping, M. E. and A. C. Faul (2003). Fast marginal likelihood maximisation 
                for sparse Bayesian models. In C. M. Bishop and B. J. Frey (Eds.), Proceedings 
                of the Ninth International Workshop on Artificial Intelligence and Statistics, 
                Key West, FL, Jan 3-6.
               </blockquote><BR><BR>C++ Example Programs: <a href="rvm_regression_ex.cpp.html">rvm_regression_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/rvm_abstract.h.html#rvm_regression_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="rvm_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">rvm_trainer</h1><BR><BR><p>
               Trains a relevance vector machine for solving binary classification problems.  
               Outputs a <a href="#decision_function">decision_function</a> that represents the learned classifier. 
            </p>
               The implementation of the RVM training algorithm used by this library is based
               on the following paper:
               <blockquote>
                Tipping, M. E. and A. C. Faul (2003). Fast marginal likelihood maximisation 
                for sparse Bayesian models. In C. M. Bishop and B. J. Frey (Eds.), Proceedings 
                of the Ninth International Workshop on Artificial Intelligence and Statistics, 
                Key West, FL, Jan 3-6.
               </blockquote><BR><BR>C++ Example Programs: <a href="rvm_ex.cpp.html">rvm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/rvm_abstract.h.html#rvm_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sammon_projection"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sammon_projection</h1><BR><BR>
                This is a function object that computes the Sammon projection of a set
                of N points in a L-dimensional vector space onto a d-dimensional space
                (d &lt; L), according to the paper:
                <blockquote>
                    A Nonlinear Mapping for Data Structure Analysis (1969) by J.W. Sammon
                </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/sammon_abstract.h.html#sammon_projection">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="save_image_dataset_metadata"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">save_image_dataset_metadata</h1><BR><BR>
            This routine is a tool for saving labeled image metadata to an 
            XML file.  In particular, this routine saves the metadata into a
            form which can be read by the <a href="#load_image_dataset_metadata">load_image_dataset_metadata</a>
            routine.  Note also that this is the metadata
            format used by the image labeling tool included with dlib in the
            tools/imglab folder.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/data_io/image_dataset_metadata.h.html#save_image_dataset_metadata">More Details...</a><div class="include_file">#include &lt;dlib/data_io.h&gt;</div></div></div><a name="save_libsvm_formatted_data"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">save_libsvm_formatted_data</h1><BR><BR>
            This is actually a pair of overloaded functions.  Between the two of them
            they let you save <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse</a> 
            or dense data vectors to file using the LIBSVM format.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/data_io/libsvm_io_abstract.h.html#save_libsvm_formatted_data">More Details...</a><div class="include_file">#include &lt;dlib/data_io.h&gt;</div></div></div><a name="segment_number_line"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">segment_number_line</h1><BR><BR>
            This routine clusters real valued scalars in essentially linear time.  
            It uses a combination of bottom up clustering and a simple greedy scan
            to try and find the most compact set of ranges that contain all
            given scalar values. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/clustering/bottom_up_cluster_abstract.h.html#segment_number_line">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="select_all_distinct_labels"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">select_all_distinct_labels</h1><BR><BR>
              This is a function which determines all distinct values present in a 
              std::vector and returns the result.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/multiclass_tools_abstract.h.html#select_all_distinct_labels">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sequence_labeler"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sequence_labeler</h1><BR><BR>
               This object is a tool for doing sequence labeling.  In particular,
               it is capable of representing sequence labeling models such as
               those produced by Hidden Markov SVMs or Conditional Random fields.
               See the following papers for an introduction to these techniques:
               <blockquote>
                    Hidden Markov Support Vector Machines by 
                     Y. Altun, I. Tsochantaridis, T. Hofmann
                  <br>
                    Shallow Parsing with Conditional Random Fields by 
                     Fei Sha and Fernando Pereira
               </blockquote><BR><BR>C++ Example Programs: <a href="sequence_labeler_ex.cpp.html">sequence_labeler_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sequence_labeler_abstract.h.html#sequence_labeler">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sequence_segmenter"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sequence_segmenter</h1><BR><BR>
                This object is a tool for segmenting a sequence of objects into a set of
                non-overlapping chunks.  An example sequence segmentation task is to take
                English sentences and identify all the named entities.  In this example,
                you would be using a sequence_segmenter to find all the chunks of
                contiguous words which refer to proper names.

               <p>
                Internally, the sequence_segmenter uses the BIO (Begin, Inside, Outside) or
                BILOU (Begin, Inside, Last, Outside, Unit) sequence tagging model.
                Moreover, it is implemented using a <a href="#sequence_labeler">sequence_labeler</a>
                object and therefore sequence_segmenter objects are examples of
                chain structured conditional random field style sequence
                taggers. 
               </p><BR><BR>C++ Example Programs: <a href="sequence_segmenter_ex.cpp.html">sequence_segmenter_ex.cpp</a><BR>Python Example Programs: <a href="sequence_segmenter.py.html">sequence_segmenter.py</a>,
               <div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sequence_segmenter_abstract.h.html#sequence_segmenter">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="shape_predictor_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">shape_predictor_trainer</h1><BR><BR>
               This object is a tool for training <a href="imaging.html#shape_predictor">shape_predictors</a> 
               based on annotated training images.  Its implementation uses the algorithm described in:
                <blockquote>
                    One Millisecond Face Alignment with an Ensemble of Regression Trees
                    by Vahid Kazemi and Josephine Sullivan, CVPR 2014
                </blockquote>
               It is capable of learning high quality shape models.  For example, this is an example output
               for one of the faces in the HELEN face dataset: <br><br><img src="face_landmarking_example.png" border="0" height="" width="" alt=""><BR><BR>C++ Example Programs: <a href="train_shape_predictor_ex.cpp.html">train_shape_predictor_ex.cpp</a><BR>Python Example Programs: <a href="train_shape_predictor.py.html">train_shape_predictor.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/shape_predictor_trainer_abstract.h.html#shape_predictor_trainer">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="sigmoid_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sigmoid_kernel</h1><BR><BR>
                This object represents a sigmoid kernel for use with
                kernel learning machines.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/kernel_abstract.h.html#sigmoid_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="simplify_linear_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">simplify_linear_decision_function</h1><BR><BR>
            This is a set of functions that takes various forms of linear <a href="#decision_function">decision functions</a>
            and collapses them down so that they only compute a single dot product when invoked. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/simplify_linear_decision_function_abstract.h.html#simplify_linear_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sort_basis_vectors"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sort_basis_vectors</h1><BR><BR>
              A kernel based learning method ultimately needs to select a set of basis functions
              represented by a particular choice of kernel and a set of basis vectors.  
              sort_basis_vectors() is a function which attempts to perform supervised
              basis set selection.  In particular, you give it a candidate set of basis
              vectors and it sorts them according to how useful they are for solving
              a particular decision problem.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sort_basis_vectors_abstract.h.html#sort_basis_vectors">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sparse_histogram_intersection_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sparse_histogram_intersection_kernel</h1><BR><BR>
                This object represents a histogram intersection kernel kernel for use with
                kernel learning machines that operate on 
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sparse_kernel_abstract.h.html#sparse_histogram_intersection_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sparse_linear_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sparse_linear_kernel</h1><BR><BR>
                This object represents a linear kernel for use with
                kernel learning machines that operate on
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sparse_kernel_abstract.h.html#sparse_linear_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sparse_polynomial_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sparse_polynomial_kernel</h1><BR><BR>
                This object represents a polynomial kernel for use with
                kernel learning machines that operate on
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sparse_kernel_abstract.h.html#sparse_polynomial_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sparse_radial_basis_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sparse_radial_basis_kernel</h1><BR><BR>
                This object represents a radial basis function kernel for use with
                kernel learning machines that operate on
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sparse_kernel_abstract.h.html#sparse_radial_basis_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="sparse_sigmoid_kernel"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">sparse_sigmoid_kernel</h1><BR><BR>
                This object represents a sigmoid kernel for use with
                kernel learning machines that operate on 
                <a href="dlib/svm/sparse_vector_abstract.h.html#sparse_vectors">sparse vectors</a>.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/sparse_kernel_abstract.h.html#sparse_sigmoid_kernel">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="spectral_cluster"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">spectral_cluster</h1><BR><BR>
             This function performs the clustering algorithm described in the paper
             <blockquote>On spectral clustering: Analysis and an algorithm by Ng, Jordan, and Weiss.</blockquote><BR><BR>C++ Example Programs: <a href="kkmeans_ex.cpp.html">kkmeans_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/clustering/spectral_cluster_abstract.h.html#spectral_cluster">More Details...</a><div class="include_file">#include &lt;dlib/clustering.h&gt;</div></div></div><a name="structural_assignment_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_assignment_trainer</h1><BR><BR>
                This object is a tool for learning to solve an assignment problem based
                on a training dataset of example assignments.  The training procedure produces an 
                <a href="#assignment_function">assignment_function</a> object which can be used 
                to predict the assignments of new data.


                Note that this is just a convenience wrapper around the 
                <a href="#structural_svm_assignment_problem">structural_svm_assignment_problem</a> 
                to make it look similar to all the other trainers in dlib.  
         <BR><BR>C++ Example Programs: <a href="assignment_learning_ex.cpp.html">assignment_learning_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_assignment_trainer_abstract.h.html#structural_assignment_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_graph_labeling_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_graph_labeling_trainer</h1><BR><BR>
                This object is a tool for learning to solve a graph labeling problem based
                on a training dataset of example labeled <a href="containers.html#graph">graphs</a>. 
                The training procedure produces a <a href="#graph_labeler">graph_labeler</a> object 
                which can be used to predict the labelings of new graphs.

               <p>
               To elaborate, a graph labeling problem is a task to learn a binary classifier which 
               predicts the label of each node in a graph.  Additionally, we have information in 
               the form of edges between nodes where edges are present when we believe the 
               linked nodes are likely to have the same label.  Therefore, part of a graph labeling 
               problem is to learn to score each edge in terms of how strongly the edge should enforce 
               labeling consistency between its two nodes.  
               </p><p>
                Note that this is just a convenience wrapper around the 
                <a href="#structural_svm_graph_labeling_problem">structural_svm_graph_labeling_problem</a> 
                to make it look similar to all the other trainers in dlib.   You might also
                consider reading the book
                <i><a href="http://www.nowozin.net/sebastian/papers/nowozin2011structured-tutorial.pdf">Structured 
                Prediction and Learning in Computer Vision</a></i> by Sebastian 
                Nowozin and Christoph H. Lampert since it contains a good introduction to machine learning
                methods such as the algorithm implemented by the structural_graph_labeling_trainer.
            </p><BR><BR>C++ Example Programs: <a href="graph_labeling_ex.cpp.html">graph_labeling_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_graph_labeling_trainer_abstract.h.html#structural_graph_labeling_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_object_detection_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_object_detection_trainer</h1><BR><BR>
               This object is a tool for learning to detect objects in images based on a set of labeled images.  
               The training procedure produces an <a href="imaging.html#object_detector">object_detector</a> which
               can be used to predict the locations of objects in new images. 
               It learns the parameter vector by formulating the problem as a <a href="#structural_svm_problem">structural SVM problem</a>.  
               The exact details of the method are described in the paper 
               <a href="http://arxiv.org/abs/1502.00046">Max-Margin Object Detection</a> by Davis E. King.
               <p>
               Note that this is just a convenience wrapper around the 
               <a href="#structural_svm_object_detection_problem">structural_svm_object_detection_problem</a>
               to make it look similar to all the other trainers in dlib.  
               </p><BR><BR>C++ Example Programs: <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a>,
               <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="object_detector_advanced_ex.cpp.html">object_detector_advanced_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a><BR>Python Example Programs: <a href="train_object_detector.py.html">train_object_detector.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_object_detection_trainer_abstract.h.html#structural_object_detection_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_sequence_labeling_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_sequence_labeling_trainer</h1><BR><BR>
                This object is a tool for learning to do sequence labeling based
                on a set of training data.  The training procedure produces a
                <a href="#sequence_labeler">sequence_labeler</a> object which can 
                be use to predict the labels of new data sequences.
               <p>
               Note that this is just a convenience wrapper around the 
               <a href="#structural_svm_sequence_labeling_problem">structural_svm_sequence_labeling_problem</a>
               to make it look similar to all the other trainers in dlib.  
               </p><BR><BR>C++ Example Programs: <a href="sequence_labeler_ex.cpp.html">sequence_labeler_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_sequence_labeling_trainer_abstract.h.html#structural_sequence_labeling_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_sequence_segmentation_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_sequence_segmentation_trainer</h1><BR><BR>
                This object is a tool for learning to do sequence segmentation based on a
                set of training data.  The training procedure produces a <a href="#sequence_segmenter">sequence_segmenter</a>
                object which can be used to identify the sub-segments of new data sequences.
               <p>
                  This object internally uses the <a href="#structural_sequence_labeling_trainer">structural_sequence_labeling_trainer</a> 
                  to solve the learning problem.  
               </p><BR><BR>C++ Example Programs: <a href="sequence_segmenter_ex.cpp.html">sequence_segmenter_ex.cpp</a><BR>Python Example Programs: <a href="sequence_segmenter.py.html">sequence_segmenter.py</a>,
               <div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_sequence_segmentation_trainer_abstract.h.html#structural_sequence_segmentation_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_svm_assignment_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_svm_assignment_problem</h1><BR><BR>
                This object is a tool for learning the parameters needed to use
                an <a href="#assignment_function">assignment_function</a> object.  
                It learns the parameters by formulating the problem as a 
                <a href="#structural_svm_problem">structural SVM problem</a>.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_assignment_problem_abstract.h.html#structural_svm_assignment_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_svm_graph_labeling_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_svm_graph_labeling_problem</h1><BR><BR>
                This object is a tool for learning the weight vectors needed to use
                a <a href="#graph_labeler">graph_labeler</a> object.  
                It learns the parameter vectors by 
                formulating the problem as a <a href="#structural_svm_problem">structural SVM problem</a>.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_graph_labeling_problem_abstract.h.html#structural_svm_graph_labeling_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_svm_object_detection_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_svm_object_detection_problem</h1><BR><BR>
               This object is a tool for learning the parameter vector needed to use
               a <a href="imaging.html#scan_fhog_pyramid">scan_fhog_pyramid</a>,
               <a href="imaging.html#scan_image_pyramid">scan_image_pyramid</a>,
               <a href="imaging.html#scan_image_boxes">scan_image_boxes</a>, or
               <a href="imaging.html#scan_image_custom">scan_image_custom</a> object.  

            <p>
               It learns the parameter vector by formulating the problem as a <a href="#structural_svm_problem">structural SVM problem</a>.  
               The exact details of the method are described in the paper 
               <a href="http://arxiv.org/abs/1502.00046">Max-Margin Object Detection</a> by Davis E. King.
            </p><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_object_detection_problem_abstract.h.html#structural_svm_object_detection_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_svm_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_svm_problem</h1><BR><BR>
                This object, when used with the <a href="optimization.html#oca">oca</a> optimizer, is a tool 
                for solving the optimization problem associated 
                with a structural support vector machine.  A structural SVM is a supervised 
                machine learning method for learning to predict complex outputs.  This is
                contrasted with a binary classifier which makes only simple yes/no
                predictions.  A structural SVM, on the other hand, can learn to predict
                complex outputs such as entire parse trees or DNA sequence alignments.  To
                do this, it learns a function F(x,y) which measures how well a particular
                data sample x matches a label y.  When used for prediction, the best label
                for a new x is given by the y which maximizes F(x,y).   

                <br><br>

                For an introduction to structured support vector machines you should consult 
                the following paper: 
                <blockquote>
                    Predicting Structured Objects with Support Vector Machines by 
                    Thorsten Joachims, Thomas Hofmann, Yisong Yue, and Chun-nam Yu
                </blockquote>

                For a more detailed discussion of the particular algorithm implemented by this
                object see the following paper:  
                <blockquote>
                    T. Joachims, T. Finley, Chun-Nam Yu, Cutting-Plane Training of Structural SVMs, 
                    Machine Learning, 77(1):27-59, 2009.
                </blockquote>
                Note that this object is essentially a tool for solving the 1-Slack structural
                SVM with margin-rescaling.  Specifically, see Algorithm 3 in the above referenced 
                paper.

               <br><br>
                Finally, for a very detailed introduction to this subject, you should consider the book:
                <blockquote><i><a href="http://www.nowozin.net/sebastian/papers/nowozin2011structured-tutorial.pdf">Structured 
                     Prediction and Learning in Computer Vision</a></i> by Sebastian Nowozin and 
                     Christoph H. Lampert
                </blockquote><BR><BR>C++ Example Programs: <a href="svm_struct_ex.cpp.html">svm_struct_ex.cpp</a><BR>Python Example Programs: <a href="svm_struct.py.html">svm_struct.py</a>,
               <div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_problem_abstract.h.html#structural_svm_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="structural_svm_problem_threaded"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_svm_problem_threaded</h1><BR><BR>
            This is just a version of the <a href="#structural_svm_problem">structural_svm_problem</a> 
            which is capable of using multiple cores/threads at a time.  You should use it if
            you have a multi-core CPU and the separation oracle takes a long time to compute.  Or even better, if you
            have multiple computers then you can use the <a href="#svm_struct_controller_node">svm_struct_controller_node</a>
            to distribute the work across many computers.
         <BR><BR>C++ Example Programs: <a href="svm_struct_ex.cpp.html">svm_struct_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_problem_threaded_abstract.h.html#structural_svm_problem_threaded">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_svm_sequence_labeling_problem"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_svm_sequence_labeling_problem</h1><BR><BR>
                This object is a tool for learning the weight vector needed to use
                a <a href="#sequence_labeler">sequence_labeler</a> object.  

                It learns the parameter vector by formulating the problem as a 
                <a href="#structural_svm_problem">structural SVM problem</a>.  
                The general approach is discussed in the paper:
                <blockquote>
                    Hidden Markov Support Vector Machines by 
                    Y. Altun, I. Tsochantaridis, T. Hofmann
                </blockquote>
                While the particular optimization strategy used is the method from: 
                <blockquote>
                    T. Joachims, T. Finley, Chun-Nam Yu, Cutting-Plane Training of 
                    Structural SVMs, Machine Learning, 77(1):27-59, 2009.
                </blockquote><BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_sequence_labeling_problem_abstract.h.html#structural_svm_sequence_labeling_problem">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="structural_track_association_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">structural_track_association_trainer</h1><BR><BR>
                This object is a tool for learning to solve a track association problem.  That
                is, it takes in a set of training data and outputs a 
                <a href="#track_association_function">track_association_function</a>
                you can use to do detection to track association.  
         <BR><BR>C++ Example Programs: <a href="learning_to_track_ex.cpp.html">learning_to_track_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_track_association_trainer_abstract.h.html#structural_track_association_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="svm_c_ekm_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_c_ekm_trainer</h1><BR><BR>
                This object represents a tool for training the C formulation of 
                a support vector machine for solving binary classification problems.   
                It is implemented using the <a href="#empirical_kernel_map">empirical_kernel_map</a>
                to kernelize the <a href="#svm_c_linear_trainer">svm_c_linear_trainer</a>.  This makes it a very fast algorithm
                capable of learning from very large datasets.

         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_c_ekm_trainer_abstract.h.html#svm_c_ekm_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_c_linear_dcd_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_c_linear_dcd_trainer</h1><BR><BR>
                This object represents a tool for training the C formulation of 
                a support vector machine to solve binary classification problems. 
                It is optimized for the case where linear kernels are used and  
                is implemented using the method described in the 
                following paper:
                <blockquote>
                    A Dual Coordinate Descent Method for Large-scale Linear SVM
                    by Cho-Jui Hsieh, Kai-Wei Chang, and Chih-Jen Lin
                </blockquote>

                This trainer has the ability to disable the bias term and also
                to force the last element of the learned weight vector to be 1.
                Additionally, it can be warm-started from the solution to a previous
                training run.
         <BR><BR>C++ Example Programs: <a href="one_class_classifiers_ex.cpp.html">one_class_classifiers_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_c_linear_dcd_trainer_abstract.h.html#svm_c_linear_dcd_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_c_linear_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_c_linear_trainer</h1><BR><BR>
                This object represents a tool for training the C formulation of 
                a support vector machine to solve binary classification problems. 
                It is optimized for the case where linear kernels are used and  
                is implemented using the <a href="optimization.html#oca">oca</a>  
                optimizer and uses the exact line search described in the 
                following paper:
                <blockquote>
                    Optimized Cutting Plane Algorithm for Large-Scale Risk Minimization
                      by  Vojtech Franc, Soren Sonnenburg; Journal of Machine Learning 
                      Research, 10(Oct):2157--2192, 2009. 
                </blockquote>

               This trainer has the ability to restrict the learned weights to non-negative
               values.
         <BR><BR>C++ Example Programs: <a href="svm_sparse_ex.cpp.html">svm_sparse_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_c_linear_trainer_abstract.h.html#svm_c_linear_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_c_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_c_trainer</h1><BR><BR><p>
               Trains a C support vector machine for solving binary classification problems 
               and outputs a <a href="#decision_function">decision_function</a>. 
               It is implemented using the <a href="optimization.html#solve_qp3_using_smo">SMO</a> algorithm.
            </p>
               The implementation of the C-SVM training algorithm used by this library is based
               on the following paper:
               <ul><li>Chih-Chung Chang and Chih-Jen Lin, LIBSVM : a library for support vector 
                     machines, 2001. Software available at 
                     <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm">http://www.csie.ntu.edu.tw/~cjlin/libsvm</a></li></ul><BR><BR>C++ Example Programs: <a href="svm_c_ex.cpp.html">svm_c_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_c_trainer_abstract.h.html#svm_c_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_multiclass_linear_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_multiclass_linear_trainer</h1><BR><BR>
                This object represents a tool for training a multiclass support 
                vector machine.  It is optimized for the case where linear kernels 
                are used and implemented using the <a href="#structural_svm_problem">structural_svm_problem</a>
                object.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_multiclass_linear_trainer_abstract.h.html#svm_multiclass_linear_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="svm_nu_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_nu_trainer</h1><BR><BR><p>
               Trains a nu support vector machine for solving binary classification problems and 
               outputs a <a href="#decision_function">decision_function</a>. 
               It is implemented using the <a href="optimization.html#solve_qp2_using_smo">SMO</a> algorithm.
            </p>
               The implementation of the nu-svm training algorithm used by this library is based
               on the following excellent papers:
               <ul><li>Chang and Lin, Training {nu}-Support Vector Classifiers: Theory and Algorithms</li><li>Chih-Chung Chang and Chih-Jen Lin, LIBSVM : a library for support vector 
                     machines, 2001. Software available at 
                     <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm">http://www.csie.ntu.edu.tw/~cjlin/libsvm</a></li></ul><BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a>,
               <a href="model_selection_ex.cpp.html">model_selection_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_nu_trainer_abstract.h.html#svm_nu_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_one_class_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_one_class_trainer</h1><BR><BR><p>
               Trains a one-class support vector classifier and outputs a <a href="#decision_function">decision_function</a>. 
               It is implemented using the <a href="optimization.html#solve_qp3_using_smo">SMO</a> algorithm.
            </p>
               The implementation of the one-class training algorithm used by this library is based
               on the following paper:
               <ul><li>Chih-Chung Chang and Chih-Jen Lin, LIBSVM : a library for support vector 
                     machines, 2001. Software available at 
                     <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm">http://www.csie.ntu.edu.tw/~cjlin/libsvm</a></li></ul><BR><BR>C++ Example Programs: <a href="one_class_classifiers_ex.cpp.html">one_class_classifiers_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_one_class_trainer_abstract.h.html#svm_one_class_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_pegasos"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_pegasos</h1><BR><BR>
                This object implements an online algorithm for training a support 
                vector machine for solving binary classification problems.  

            <p>
                The implementation of the Pegasos algorithm used by this object is based
                on the following excellent paper:
               <blockquote>
                    Pegasos: Primal estimated sub-gradient solver for SVM (2007)
                    by Shai Shalev-Shwartz, Yoram Singer, Nathan Srebro 
                    In ICML 
               </blockquote></p><p>
                This SVM training algorithm has two interesting properties.  First, the 
                pegasos algorithm itself converges to the solution in an amount of time
                unrelated to the size of the training set (in addition to being quite fast
                to begin with).  This makes it an appropriate algorithm for learning from
                very large datasets.  Second, this object uses the <a href="#kcentroid">kcentroid</a> object 
                to maintain a sparse approximation of the learned decision function.  
                This means that the number of support vectors in the resulting decision 
                function is also unrelated to the size of the dataset (in normal SVM
                training algorithms, the number of support vectors grows approximately 
                linearly with the size of the training set).  
            </p><p>
              However, if you are considering using svm_pegasos, you should also try the 
              <a href="#svm_c_linear_trainer">svm_c_linear_trainer</a> for linear
              kernels or <a href="#svm_c_ekm_trainer">svm_c_ekm_trainer</a> for non-linear
              kernels since these other trainers are, usually, faster and easier to use
              than svm_pegasos.
            </p><BR><BR>C++ Example Programs: <a href="svm_pegasos_ex.cpp.html">svm_pegasos_ex.cpp</a>,
               <a href="svm_sparse_ex.cpp.html">svm_sparse_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/pegasos_abstract.h.html#svm_pegasos">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_rank_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_rank_trainer</h1><BR><BR>
                This object represents a tool for training a ranking support vector machine
                using linear kernels.  In particular, this object is a tool for training
                the Ranking SVM described in the paper: 
                <blockquote>
                    Optimizing Search Engines using Clickthrough Data by Thorsten Joachims
                </blockquote>
                Finally, note that the implementation of this object is done using the 
                <a href="optimization.html#oca">oca</a> optimizer and 
                <a href="#count_ranking_inversions">count_ranking_inversions</a> method.
                This means that it runs in O(n*log(n)) time, making it suitable for use
                with large datasets.
         <BR><BR>C++ Example Programs: <a href="svm_rank_ex.cpp.html">svm_rank_ex.cpp</a><BR>Python Example Programs: <a href="svm_rank.py.html">svm_rank.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_rank_trainer_abstract.h.html#svm_rank_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svm_struct_controller_node"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_struct_controller_node</h1><BR><BR>
            This object is a tool for distributing the work involved in solving a 
            <a href="#structural_svm_problem">structural_svm_problem</a> across many computers.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_distributed_abstract.h.html#svm_struct_controller_node">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="svm_struct_processing_node"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svm_struct_processing_node</h1><BR><BR>
            This object is a tool for distributing the work involved in solving a 
            <a href="#structural_svm_problem">structural_svm_problem</a> across many computers.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/structural_svm_distributed_abstract.h.html#svm_struct_processing_node">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="svr_linear_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svr_linear_trainer</h1><BR><BR>
                This object implements a trainer for performing epsilon-insensitive support
                vector regression.  It uses the <a href="optimization.html#oca">oca</a> 
                optimizer so it is very efficient at solving this problem when
                linear kernels are used, making it suitable for use with large
                datasets. 
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svr_linear_trainer_abstract.h.html#svr_linear_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="svr_trainer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">svr_trainer</h1><BR><BR><p>
                This object implements a trainer for performing epsilon-insensitive support 
                vector regression.  It is implemented using the <a href="optimization.html#solve_qp3_using_smo">SMO</a> algorithm, 
                allowing the use of non-linear kernels.
                If you are interested in performing support vector regression with a linear kernel and you
                have a lot of training data then you should use the <a href="#svr_linear_trainer">svr_linear_trainer</a>
                which is highly optimized for this case.
            </p>
                The implementation of the eps-SVR training algorithm used by this object is based
                on the following paper:
               <ul><li>Chih-Chung Chang and Chih-Jen Lin, LIBSVM : a library for support vector 
                     machines, 2001. Software available at 
                     <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm">http://www.csie.ntu.edu.tw/~cjlin/libsvm</a></li></ul><BR><BR>C++ Example Programs: <a href="svr_ex.cpp.html">svr_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svr_trainer_abstract.h.html#svr_trainer">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_assignment_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_assignment_function</h1><BR><BR>
            Tests an <a href="#assignment_function">assignment_function</a> on a set of data 
            and returns the fraction of assignments predicted correctly.
         <BR><BR>C++ Example Programs: <a href="assignment_learning_ex.cpp.html">assignment_learning_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_assignment_trainer_abstract.h.html#test_assignment_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_binary_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_binary_decision_function</h1><BR><BR>
            Tests a <a href="#decision_function">decision_function</a> that represents a binary decision function and
            returns the test accuracy.  

         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#test_binary_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_graph_labeling_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_graph_labeling_function</h1><BR><BR>
            Tests a <a href="#graph_labeler">graph_labeler</a> on a set of data 
            and returns the fraction of labels predicted correctly.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_graph_labeling_trainer_abstract.h.html#test_graph_labeling_function">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="test_layer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_layer</h1><BR><BR>
            This is a function which tests if a layer object correctly implements
            the <a href="dlib/dnn/layers_abstract.h.html#EXAMPLE_COMPUTATIONAL_LAYER_">documented contract</a>
            for a computational layer in a deep neural network.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/dnn/core_abstract.h.html#test_layer">More Details...</a><div class="include_file">#include &lt;dlib/dnn.h&gt;</div></div></div><a name="test_multiclass_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_multiclass_decision_function</h1><BR><BR>
            Tests a multiclass decision function (e.g. <a href="#one_vs_one_decision_function">one_vs_one_decision_function</a>)
            and returns a confusion matrix describing the results.
         <BR><BR>C++ Example Programs: <a href="multiclass_classification_ex.cpp.html">multiclass_classification_ex.cpp</a>,
               <a href="custom_trainer_ex.cpp.html">custom_trainer_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_multiclass_trainer_abstract.h.html#test_multiclass_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_object_detection_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_object_detection_function</h1><BR><BR>
            Tests an object detector such
            as the <a href="imaging.html#object_detector">object_detector</a> 
            and returns the precision and recall. 
         <BR><BR>C++ Example Programs: <a href="fhog_object_detector_ex.cpp.html">fhog_object_detector_ex.cpp</a>,
               <a href="object_detector_ex.cpp.html">object_detector_ex.cpp</a>,
               <a href="object_detector_advanced_ex.cpp.html">object_detector_advanced_ex.cpp</a>,
               <a href="train_object_detector.cpp.html">train_object_detector.cpp</a>,
               <a href="dnn_mmod_ex.cpp.html">dnn_mmod_ex.cpp</a>,
               <a href="dnn_mmod_find_cars_ex.cpp.html">dnn_mmod_find_cars_ex.cpp</a>,
               <a href="dnn_mmod_train_find_cars_ex.cpp.html">dnn_mmod_train_find_cars_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_object_detection_trainer_abstract.h.html#test_object_detection_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_ranking_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_ranking_function</h1><BR><BR>
            Tests a <a href="#decision_function">decision_function</a>'s ability to correctly 
            rank a dataset and returns the resulting ranking accuracy and mean average precision metrics.
         <BR><BR>C++ Example Programs: <a href="svm_rank_ex.cpp.html">svm_rank_ex.cpp</a><BR>Python Example Programs: <a href="svm_rank.py.html">svm_rank.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/ranking_tools_abstract.h.html#test_ranking_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_regression_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_regression_function</h1><BR><BR>
            Tests a regression function (e.g. <a href="#decision_function">decision_function</a>)
            and returns the mean squared error and R-squared value.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_regression_trainer_abstract.h.html#test_regression_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_sequence_labeler"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_sequence_labeler</h1><BR><BR>
            Tests a <a href="#sequence_labeler">sequence_labeler</a> on a set of data 
            and returns a confusion matrix describing the results.
         <BR><BR>C++ Example Programs: <a href="sequence_labeler_ex.cpp.html">sequence_labeler_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_sequence_labeler_abstract.h.html#test_sequence_labeler">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_sequence_segmenter"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_sequence_segmenter</h1><BR><BR>
            Tests a <a href="#sequence_segmenter">sequence_segmenter</a> on a set of data 
            and returns the resulting precision, recall, and F1-score.
         <BR><BR>C++ Example Programs: <a href="sequence_segmenter_ex.cpp.html">sequence_segmenter_ex.cpp</a><BR>Python Example Programs: <a href="sequence_segmenter.py.html">sequence_segmenter.py</a>,
               <div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_sequence_segmenter_abstract.h.html#test_sequence_segmenter">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="test_shape_predictor"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_shape_predictor</h1><BR><BR>
            Tests a <a href="imaging.html#shape_predictor">shape_predictor</a>'s ability to correctly 
            predict the part locations of objects.  The output is the average distance (measured in pixels) between
            each part and its true location.  You can optionally normalize each distance using a 
            user supplied scale.  For example, when performing face landmarking, you might want to
            normalize the distances by the interocular distance.
         <BR><BR>C++ Example Programs: <a href="train_shape_predictor_ex.cpp.html">train_shape_predictor_ex.cpp</a><BR>Python Example Programs: <a href="train_shape_predictor.py.html">train_shape_predictor.py</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/image_processing/shape_predictor_abstract.h.html#test_shape_predictor">More Details...</a><div class="include_file">#include &lt;dlib/image_processing.h&gt;</div></div></div><a name="test_track_association_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">test_track_association_function</h1><BR><BR>
            Tests a <a href="#track_association_function">track_association_function</a> on a set of data 
            and returns the fraction of detections which were correctly associated to their tracks.
         <BR><BR>C++ Example Programs: <a href="learning_to_track_ex.cpp.html">learning_to_track_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/cross_validate_track_association_trainer_abstract.h.html#test_track_association_function">More Details...</a><div class="include_file">#include &lt;dlib/svm_threaded.h&gt;</div></div></div><a name="track_association_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">track_association_function</h1><BR><BR>
                This object is a tool that helps you implement an object tracker.  So for
                example, if you wanted to track people moving around in a video then this
                object can help.  In particular, imagine you have a tool for detecting the
                positions of each person in an image.  Then you can run this person
                detector on the video and at each time step, i.e. at each frame, you get a
                set of person detections.  However, that by itself doesn't tell you how
                many people there are in the video and where they are moving to and from.
                To get that information you need to figure out which detections match each
                other from frame to frame.  This is where the track_association_function
                comes in.  It performs the detection to track association.  It will also do
                some of the track management tasks like creating a new track when a
                detection doesn't match any of the existing tracks.

               <p>
                  Internally, this object is implemented using the 
                  <a href="#assignment_function">assignment_function</a> object.  
                In fact, it's really just a thin wrapper around assignment_function and
                exists just to provide a more convenient interface to users doing detection
                to track association.   
               </p><BR><BR>C++ Example Programs: <a href="learning_to_track_ex.cpp.html">learning_to_track_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/track_association_function_abstract.h.html#track_association_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="train_probabilistic_decision_function"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">train_probabilistic_decision_function</h1><BR><BR><p>
               Trains a <a href="#probabilistic_function">probabilistic_function</a> using 
               some sort of binary classification trainer object such as the <a href="#svm_nu_trainer">svm_nu_trainer</a> or
               <a href="#krr_trainer">krr_trainer</a>.
            </p>
            The probability model is created by using the technique described in the following papers:
            <blockquote>
                Probabilistic Outputs for Support Vector Machines and
                Comparisons to Regularized Likelihood Methods by 
                John C. Platt.  March 26, 1999
            </blockquote><blockquote>
                A Note on Platt's Probabilistic Outputs for Support Vector Machines
                by Hsuan-Tien Lin, Chih-Jen Lin, and Ruby C. Weng
            </blockquote><BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/svm_abstract.h.html#train_probabilistic_decision_function">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="vector_normalizer"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">vector_normalizer</h1><BR><BR>
                This object represents something that can learn to normalize a set 
                of column vectors.  In particular, normalized column vectors should 
                have zero mean and a variance of one.  
         <BR><BR>C++ Example Programs: <a href="svm_ex.cpp.html">svm_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/statistics_abstract.h.html#vector_normalizer">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="vector_normalizer_frobmetric"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">vector_normalizer_frobmetric</h1><BR><BR>
                This object is a tool for performing the FrobMetric distance metric
                learning algorithm described in the following paper:
                <blockquote>
                    A Scalable Dual Approach to Semidefinite Metric Learning
                    By Chunhua Shen, Junae Kim, Lei Wang, in CVPR 2011
                </blockquote>
                Therefore, this object is a tool that takes as input training triplets
                (anchor, near, far) of vectors and attempts to learn a linear
                transformation T such that:
                <blockquote><tt>length(T*anchor-T*near) + 1 &lt; length(T*anchor - T*far)</tt></blockquote>
                That is, you give a bunch of anchor vectors and for each anchor vector you
                specify some vectors which should be near to it and some that should be far
                form it.  This object then tries to find a transformation matrix that makes
                the "near" vectors close to their anchors while the "far" vectors are
                farther away.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/vector_normalizer_frobmetric_abstract.h.html#vector_normalizer_frobmetric">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="vector_normalizer_pca"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">vector_normalizer_pca</h1><BR><BR>
                This object represents something that can learn to normalize a set 
                of column vectors.  In particular, normalized column vectors should 
                have zero mean and a variance of one.  

                This object also uses principal component analysis for the purposes 
                of reducing the number of elements in a vector.  
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/statistics/statistics_abstract.h.html#vector_normalizer_pca">More Details...</a><div class="include_file">#include &lt;dlib/statistics.h&gt;</div></div></div><a name="verbose_batch"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">verbose_batch</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects.  This function
            generates a batch_trainer that will print status messages to standard
            output so that you can observe the progress of a training algorithm.
         <BR><BR>C++ Example Programs: <a href="svm_pegasos_ex.cpp.html">svm_pegasos_ex.cpp</a><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/pegasos_abstract.h.html#verbose_batch">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div><a name="verbose_batch_cached"></a><div class="component"><a href="#top"><font size="2"><center>[top]</center></font></a><h1 style="margin:0px;">verbose_batch_cached</h1><BR><BR>
            This is a convenience function for creating 
            <a href="#batch_trainer">batch_trainer</a> objects.  This function
            generates a batch_trainer that will print status messages to standard
            output so that you can observe the progress of a training algorithm.
            It will also be configured to use a kernel matrix cache.
         <BR><div class="include_file_more_details_wrapper"><a class="more_details" href="dlib/svm/pegasos_abstract.h.html#verbose_batch_cached">More Details...</a><div class="include_file">#include &lt;dlib/svm.h&gt;</div></div></div></div></body></html>
